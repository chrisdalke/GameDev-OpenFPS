Rem Project: Dark Basic Pro Project
Rem Created: Friday, December 10, 2010

Rem ***** Main Source File *****
set display mode 320,240,32
sync on
sync rate 0
ip$="108.7.78.206"

winsock make
if winsock error()
   print "error initializing winsock!"
   print winsock error msg$()
   wait key
   `there is nothing we can do, winsock make automatically has tried all available winsock versions and has failed.
   end
endif

channel = winsock create udp channel()
winsock set channel target channel,ip$,3999

check_for_error(channel)

send$ = "hello"
make memblock 1, len(send$)+1
write_memblock_string(1, 0, send$)

do
    cls 0
    print "UDP Connection to Server"
    print "------------------------"
    print "Sending packet @ ",ip$
    winsock send udp message channel, get memblock ptr(1), get memblock size(1)
    sync
LOOP

function check_for_error(a_channel as DWORD)
`check for an error on a channel.
   if (winsock channel error(a_channel))
      `an error has occurred.
      `cls
      if winsock channel error nr(a_channel) = WSAECONNRESET
         `this error message appears if you send UDP data to an invalid destination / where no one is waiting for it.
         `reset channel error.
         winsock reset error a_channel
         print "invalid destination"
      else
         print winsock channel error msg$(a_channel)
         wait key
         winsock clean up
         end
      endif
   endif
endfunction

function write_memblock_string(memblock_nr as INTEGER, position as INTEGER, a_string as STRING)
      `writes a string into a memblock. careful make sure the memblock has enough space from position to its end!
   for i = 0 to len(a_string)-1
      write memblock byte memblock_nr, position + i, asc(mid$(a_string, i+1))
   next i
   `terminate string with a 0-character.
   write memblock byte memblock_nr, position + i, 0
endfunction

function memblock_string(memblock_nr as INTEGER, position as INTEGER)
      `reads a null terminated string from a memblock. make sure position is within memblock size!
   result$ = ""
   i = position
   char_val = memblock byte(memblock_nr, i)
   inc i
   while char_val <> 0 and i < get memblock size(memblock_nr)
      result$ = result$ + chr$(char_val)
      char_val = memblock byte(memblock_nr, i)
      inc i
   endwhile
endfunction result$
