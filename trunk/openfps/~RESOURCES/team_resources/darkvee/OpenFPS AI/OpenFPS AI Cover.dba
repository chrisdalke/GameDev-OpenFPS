rem declare variables
   global coverCounter as integer
   global waypoint as integer
   global smallest as float
   global playerRange as float
   global playerRange2 as float
   global coverRange as float
   global playerCollisionCounter  as integer

rem set values
   playerRange            = 2.0
   playerRange2           = 10.0
   coverRange             = 10.0
   coverCounter           = 25
   playerCollisionCounter = 1

rem ai type
   type NpcType
      ObjNum as integer
      X as float
      Y as float
      Z as float
      Distance as float
      Distance2 as float
      DistanceX as float
      DistanceZ as float
      Angle as float
      Speed as float
      CurrentSpeed as float
      Direction as integer
      CoverCounter as integer
   endtype
   global npcs as integer = 7
   dim npc(npcs) as NpcType

rem waypoint goal type
   type GoalType
      ObjNum as integer
      X as float
      Y as float
      Z as float
      Distance as float
   endtype
   global goals as integer = 500
   dim goal(goals) as GoalType

rem player type
   type PlayerType
      ObjNum as integer
      X as float
      Y as float
      Z as float
      Distance as float
      Distance2 as float
   endtype
   global player as PlayerType

rem setup display
   Set_Up_Display()

rem give us true random numbers
   randomize timer()

rem make the npc
   Make_Npc()

rem make are waypoints its named goals
rem because when a ai does something that is a goal it has completed
   Make_Goals()

rem make the player
   Make_Player()

rem are main loop
do

rem update all npc settings
   Update_All_Npc_Settings()

rem update all wyapoint settings
   Update_All_Goal_Settings()

rem move the player
   Move_player()

rem make the camera follow are player
   Auto_Cam_Follow_Player()

rem debugg code just text stuff
   Debugg()

rem sync updates all are stuff
   sync

rem end of main loop
loop

function Set_Up_Display()

rem not important
   hide mouse
   autocam off
   sync on
   sync rate 60
   set display mode 1024,768,32,1
   backdrop on
   color backdrop rgb(90,90,90)
endfunction

function Make_Player()

rem set up are player
   player.ObjNum = i+1
   make object cube  player.ObjNum,1
   color object  player.ObjNum,rgb(255,0,0)
endfunction

function Make_Npc()

rem set up are npcs
   for i = 0 to npcs
      npc(i).ObjNum       = i+2
      npc(i).X            = -25+rnd(25)
      npc(i).Z            = -25+rnd(25)
      npc(i).Speed        = 0.2
      npc(i).CoverCounter = 10
      make object cube npc(i).ObjNum,1
      color object npc(i).ObjNum,rgb(0,255,0)
   next i
endfunction

function Make_Goals()

rem set up are waypoints
   for i = 0 to goals
      goal(i).ObjNum = i+10
      goal(i).X      = -78+rnd(78)*2
      goal(i).Y      = 0
      goal(i).Z      = -58+rnd(58)*2
      make object cube goal(i).ObjNum,1
      color object goal(i).ObjNum,rgb(190,190,190)
      position object goal(i).ObjNum,goal(i).X,goal(i).Y,goal(i).Z
   next i
endfunction

function Update_All_Npc_Settings()

rem updare all npcs settings
   for i = 0 to npcs

rem control the direction movement
      Npc_Movement_Direction(i)

rem use the npcs brain to do action
      Npc_Brain(i)

rem move the npcs
      Move_Npc(i)

rem make the npcs stay inbounds
      Npc_Stay_Inbounds(i)

rem update all rotation, and position data
      yrotate object npc(i).objNum,npc(i).Angle
      position object npc(i).ObjNum,npc(i).X,npc(i).Y,npc(i).Z
   next i
endfunction

function Update_All_Goal_Settings()

rem update all goal setings
   for i = 0 to goals

rem update positions
      position object goal(i).ObjNum,goal(i).X,goal(i).Y,goal(i).Z
   next i
endfunction

function Npc_Brain(i as integer)

rem the npc brain is the meat of are npcs.
rem ai current speed
   npc(i).CurrentSpeed = 0.0

rem cover collision counter
   npc(i).CoverCounter  =  npc(i).CoverCounter   - 1
   if npc(i).CoverCounter   <= 1 then  npc(i).CoverCounter  = 1

rem player collision counter
   playerCollisionCounter  =  playerCollisionCounter - 1
   if playerCollisionCounter  <= 1 then  playerCollisionCounter  = 1

rem make are  distance formula
   player.Distance = sqrt((player.X-npc(i).X)^2+(player.Z-npc(i).Z)^2)
rem if ai is greater then PlayerRange point at the player, and follow the player
   if abs(player.Distance) > playerRange
      Point_Npc_At_Player(i)
   endif

rem if player is less than playerRange then point at player, and follow him
   if abs(player.Distance) > playerRange2

rem we use this counter to give it a delay so we can pull the npcs
rem from the waypoints
      npc(i).CoverCounter  = 50
      Point_Npc_At_Player(i)
   endif

rem set smallest  to npc(i).Distance
   smallest = npc(i).Distance

   for j = 0 to goals-i
rem set up are distance formulas
      player.Distance2 = sqrt((player.X-goal(j).X)^2+(player.Z-goal(j).Z)^2)
      npc(i).Distance = sqrt((npc(i).X-goal(j).X)^2+(npc(i).Z-goal(j).Z)^2)

rem if npc distance is less than coverRange then pick the closest waypoint
rem near by, then go to the waypoint
      if abs(npc(i).Distance) < coverRange
         if abs(npc(i).Distance) < smallest
            smallest = abs(npc(i).Distance)
            waypoint = j
            if npc(i).CoverCounter = 1
               Point_Npc_At_Goal(i)
            endif
         endif
      endif

rem player collision with gray cubes
   if player.Distance2 < 1
       playerCollisionCounter =  100
      if  playerCollisionCounter > 1
         if upkey()=1    then player.Z = player.Z - 0.4
         if downkey()=1  then player.Z = player.Z + 0.4
         if rightkey()=1 then player.X = player.X - 0.4
         if leftkey()=1  then player.X = player.X + 0.4
      endif
   endif

rem npc collision with gray cubes
      if npc(i).Distance < 1
         if npc(i).CoverCounter = 1
            npc(i).CurrentSpeed = 0.0
             npc(i).Direction = 0
         endif
      endif
   next j


rem collision with each npc
   npc(i).Distance2 = sqrt((npc(i).X-npc(k).X)^2+(npc(i).Z-npc(k).Z)^2)
   if npc(i).Distance2 <1
      k = rnd(npcs)
      npc(k).CurrentSpeed = -0.4
      npc(k).Direction = rnd(3)+1
   endif

endfunction

function Point_Npc_At_Goal(i as integer)

rem get the angle of the waypoint
   npc(i).DistanceX = (npc(i).X-goal(waypoint).X)
   npc(i).DistanceZ = (npc(i).Z-goal(waypoint).Z)
   npc(i).Angle = atanfull(npc(i).DistanceX,npc(i).DistanceZ)

rem set are currentSpeed to npc(i).Speed
   npc(i).CurrentSpeed =  npc(i).Speed
endfunction

function Point_Npc_At_Player(i as integer)

rem get the angle of the player
   npc(i).DistanceX = (npc(i).X-player.X)
   npc(i).DistanceZ = (npc(i).Z-player.Z)
   npc(i).Angle = atanfull(npc(i).DistanceX,npc(i).DistanceZ)

rem set are currentSpeed to npc(i).Speed
   npc(i).CurrentSpeed =  npc(i).Speed
endfunction

function Move_Npc(i as integer)
rem this is how we calculate the right angle to move
rem were setting are angle rule to move forward
    if wrapvalue(npc(i).Angle) >= 90 and wrapvalue(npc(i).Angle) <= 270
       npc(i).Z = npc(i).Z - ( cos( wrapvalue(npc(i).Angle ) ) * npc(i).CurrentSpeed )
    endif

rem were setting are angle rule to move backwards
    if wrapvalue(npc(i).Angle) < 90 and wrapvalue(npc(i).Angle) >=0
       npc(i).Z = npc(i).Z - ( cos( wrapvalue(npc(i).Angle ) ) * npc(i).CurrentSpeed )
    endif

rem were setting are angle rule to move backwards
    if wrapvalue(npc(i).Angle) < 360 and wrapvalue(npc(i).Angle) >= 270
       npc(i).Z = npc(i).Z - ( cos( wrapvalue(npc(i).Angle ) ) * npc(i).CurrentSpeed )
    endif

rem were setting are angle rule to move left
    if wrapvalue(npc(i).Angle) >= 0 and wrapvalue(npc(i).Angle) <= 180
       npc(i).X = npc(i).X - ( sin( wrapvalue(npc(i).Angle ) ) * npc(i).CurrentSpeed )
    endif

rem were setting are angle rule to move right
    if wrapvalue(npc(i).Angle) >= 180 and wrapvalue(npc(i).Angle) <= 360
       npc(i).X = npc(i).X - ( sin( wrapvalue(npc(i).Angle ) ) * npc(i).CurrentSpeed )
    endif
endfunction

function Npc_Movement_Direction(i as integer)

rem move npc forward
   if npc(i).Direction = 1 then npc(i).Z = npc(i).Z + npc(i).CurrentSpeed

rem move npc backwards
   if npc(i).Direction = 2 then npc(i).Z = npc(i).Z - npc(i).CurrentSpeed

rem move npc right
   if npc(i).Direction = 3 then npc(i).X = npc(i).X + npc(i).CurrentSpeed

rem move npc left
   if npc(i).Direction = 4 then npc(i).X = npc(i).X - npc(i).CurrentSpeed

endfunction

function Npc_Stay_Inbounds(i as integer)

rem make the npcs stay in bounds
   if npc(i).X < -78 then npc(i).Direction = 3
   if npc(i).X >  78 then npc(i).Direction = 4
   if npc(i).Z >  58 then npc(i).Direction = 2
   if npc(i).Z < -58 then npc(i).Direction = 1
endfunction

function Move_Player()

rem if playerCollisionCounter equals 1 then we can move the player
   if playerCollisionCounter  = 1
      if upkey()=1    then player.Z = player.Z + 0.2
      if downkey()=1  then player.Z = player.Z - 0.2
      if rightkey()=1 then player.X = player.X + 0.2
      if leftkey()=1  then player.X = player.X - 0.2
   endif

rem update position data
   position object player.ObjNum,player.X,player.Y,player.Z
endfunction

function Auto_Cam_Follow_Player()

rem this is are simple follow cam
   xrotate camera 30
   position camera player.X,10,player.Z-20
endfunction

function Debugg()

rem are debugg text
   text 20,20,"move your player, and let go of the direction keys to have the ai to automatically find cover"
   text 20,40,"movement keys: "
   text 20,60,"up, down, left, right"
endfunction
