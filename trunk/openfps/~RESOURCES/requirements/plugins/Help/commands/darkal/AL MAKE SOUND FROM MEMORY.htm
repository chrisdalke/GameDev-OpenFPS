<html>
<head>
<title>DarkBASIC Professional Help File</title>
</head>
<body background="..\..\gfx\dbpro_bg.jpg">
<!-- Page Header -->
<center><table width="340" border="0" cellpadding="0" cellspacing="0">
<tr>
	<td><img src="..\..\gfx\dbph_head_1.jpg" width="340" height="51"></td>
	<td><a href="..\..\main.htm"><img src="..\..\gfx\dbph_head_2.jpg" width="47" height="51" border="0"></a></td>
	<td><a href="..\..\commands.htm"><img src="..\..\gfx\dbph_head_3.jpg" width="50" height="51" border="0"></a></td>
	<td><a href="..\..\examples.htm"><img src="..\..\gfx\dbph_head_4.jpg" width="47" height="51" border="0"></a></td>
	<td><a href="..\..\documents.htm"><img src="..\..\gfx\dbph_head_5.jpg" width="46" height="51" border="0"></a></td>
	<td><a href="..\..\index.htm"><img src="..\..\gfx\dbph_head_6.jpg" width="56" height="51" border="0"></a></td>
</tr>
</table></center>
<font face="Verdana">
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr><td>
<!-- Function Head -->
<font face="Verdana" size="5">
<b>
AL LOAD SOUND
</b>
<font face="Verdana" size="2">
<p>
This function will create a new sound from data stored in a chunk of memory space. Since it accepts a memory pointer as input, it means you can use anything from memblocks to third party methods of memory manipulation in DBPro for preparing raw audio data.
</p>
</font>
<!-- Synopsis -->
<table width="590" cellpadding="3">
<tr><td bgcolor="#0d4283"><font color="#ffffff" size="3"><b>&nbsp;
Syntax
</b></font></td></tr>
</table>
<font face="Verdana" size="3">
<pre>
AL MAKE SOUND FROM MEMORY soundNumber, memoryPointer, bytes, frequency, format
</pre>
</font>
<!-- Parameters -->
<table width="590" cellpadding="3">
<tr><td bgcolor="#0d4283"><font color="#ffffff" size="3"><b>&nbsp;
Parameters
</b></font></td></tr>
</table>
<font face="Verdana" size="3">
<pre>
soundNumber
</pre>
<blockquote>
Integer
<br>
The ID you want to use to create this sound.
</blockquote>
<pre>
memoryPointer
</pre>
<blockquote>
Double Integer
<br>
A memory pointer value where the raw audio data starts in memory.
</blockquote>
<pre>
bytes
</pre>
<blockquote>
Double Integer
<br>
The number of bytes to use as raw audio data. The size of the audio data in bytes.
</blockquote>
<pre>
frequency
</pre>
<blockquote>
Integer
<br>
The frequency to use when playing the raw audio data, in Hurtz (Hz). This is also known as the number of samples per second, or sample rate. For example, if your set the frequency to 22050 and your data contains enough information for 44100 samples, your audio data will play for exactly 2 seconds (2x 22050 = 44100).
</blockquote>
<pre>
format
</pre>
<blockquote>
Integer
<br>
The format to play the raw audio data in. Each format has a corresponding integer value which must be used with this parameter:
    <blockquote>
    0 = 8-Bit Mono<br>
    1 = 8-Bit Stereo<br> 
    2 = 16-Bit Mono<br>
    3 = 16-Bit Stereo<br>
    </blockquote>
</blockquote>
</font>
<BR>
<!-- Returns -->
<table width="590" cellpadding="3">
<tr><td bgcolor="#0d4283"><font color="#ffffff" size="3"><b>&nbsp;
Raw Audio Data Structure
</b></font></td></tr>
</table>
<font face="Verdana" size="3">
<p>
When writing the raw audio data into memory, there are several ways the data can be written and the correct format must be used for each.<br><br>
<strong>8-Bit Mono</strong><br>
In 8-bit mode, each sample is written as a single byte, which means they can only have 255 different levels of amplitude. Writing 8-Bit audio Data into memory would be done as:<br>
<pre>sample 1 | sample 2 | sample 3 | sample 4 | sample 5 | and so on -> 
BYTE 1   | BYTE 2   | BYTE 3   | BYTE 4   | BYTE 5   | and so on -></pre><br>
<strong>16-Bit Mono</strong><br>
In 16-bit mode, each sample is written as a WORD, which means they can have an amplitude level ranging from -32768 to 32767. The WORD datatype in DBPro is 16 bits in size, so it is perfect for writing 16 bit sample data into a memblock or other method of memory manipulation.<br>
<pre>sample 1 | sample 2 | sample 3 | sample 4 | sample 5 | and so on -> 
WORD 1   | WORD 2   | WORD 3   | WORD 4   | WORD 5   | and so on -></pre><br>
<strong>8-Bit Stereo</strong><br>
In 8-bit stereo mode, things get a little trickier. The raw audio data requires data for 2 channels, left and right. Samples are written in an interleaving fashion, with the first sample being left channel, followed by the sample for the right channel and so on. Again, since each sample is only 1 byte in since, they can only have 255 levels of amplitude each.
<pre>
sample 1 left | sample 1 right | sample 2 left | sample 2 right | sample 3 left | sample 3 right | and so on -> 
BYTE 1        | BYTE 2         | BYTE 3        | BYTE 4         | BYTE 5        | BYTE 6         | and so on -></pre>
<br>
<strong>16-Bit Stereo</strong><br>
The same interleaving structure as 8-bit stereo is used when writing data for left and right channels in 16-bit stereo mode, with the exception of each sample being 16-bits (2 bytes) each, allowing for amplitude levels ranging from -32768 to 32767.
<pre>
sample 1 left | sample 1 right | sample 2 left | sample 2 right | sample 3 left | sample 3 right | and so on -> 
WORD 1        | WORD 2         | WORD 3        | WORD 4         | WORD 5        | WORD 6         | and so on -></pre>
<br>
<strong>How Many Bytes are Needed</strong><br>
Before storing any audio data you obviously need to know how many bytes of memory you will need. This could be worked out as follows:
<pre>numberOfBytes = (sampleSize * numberOfSamples) * channels</pre><br>
Where 'sampleSize' is how many bytes (bits/8) each sample is and 'numberOfSamples' is the total number of samples your audio data will have. The result of those two are multiplied by the number of channels, 1 channel for mono and 2 channels for stereo.<br>
<br>
<strong>Calculating the Bit-Rate</strong><br>
Although the bitrate isn't important for creating a sound from raw data with this function, it may be useful information to know anyway. The Bit-Rate is simply how many bits are played/processed per second. This can be calculated as follows:
<pre>bitRate = frequency * sampleSize</pre><br>
Where 'sampleSize' is how many bytes (bits/8) each sample is and 'frequency' is how many samples are played per second. Dividing the result by 1000 will give you kilobits per second (kbps) which is a common sight in media players of all sorts.
</p>
</font>
<!-- Returns -->
<table width="590" cellpadding="3">
<tr><td bgcolor="#0d4283"><font color="#ffffff" size="3"><b>&nbsp;
Returns
</b></font></td></tr>
</table>
<font face="Verdana" size="2">
<p>
This function does not return a value.
</p>
</font>
<!-- Examples -->
<table width="590" cellpadding="3">
<!-- See Also -->
<table width="590" cellpadding="3">
<tr><td bgcolor="#0d4283"><font color="#ffffff" size="3"><b>&nbsp;
See also
</b></font></td></tr>
</table>
<font face="Verdana" size="2">
<p>
<a href="..\darkal.html">DarkAL Functions Menu</a>
</p>
</font>
</table>
<br>
<!-- Page Footer -->
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr>
	<td align="center"><img src="..\..\gfx\dbph_foot_1.jpg" width="340" height="38"></td>
</tr>
</table>
</body>
</html>
