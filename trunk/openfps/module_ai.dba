remstart
/////////////////////////////////////////////////////
//
// OpenFPS AI Mechanics Module
//
// Created by darkvee
//   Pathfinding by BMacZero
// Maintained by darkvee
//
/////////////////////////////////////////////////////

----- Changelog:
(2/8/10) - BMacZero - Created
(2/28/10) - BMacZero - Incorporated darkvee's code
(3/7/10) - BMacZero - Started adding my pathfinding


----- To-Do:
Replace goodNPC state 2 with cover system
Synchronize with module_shooting

----- Purpose:
This module handles all pathfinding and decision-
making for any non-player characters in the game.

If the NPCs choose to shoot or use a similar ability,
this module tells the appropriate module to take care
of it.


----- Dependancies and Conflicts (IMPORTANT STUFF):
-None-


----- Other Notes:



remend



`global timerBasedTimer as integer = timer()


`Pathfinding
type path_Vector2
    X as float
    Y as float
endtype

type path_LineType
    V1 as integer
    V2 as integer
endtype

type path_AStarNode
    F as integer
    G as integer
    H as integer
    Open as boolean
    Closed as boolean
    Parent as integer
endtype

type path_Connection
    V1 as integer
    V2 as integer
    Distance as integer
endtype



type ai_GoodNpcType
    ObjNum as integer
    X as float
    Y as float
    Z as float
    Speed as float
    Distance as Float
    Distance2 as float
    DistanceX as float
    DistanceZ as float
    Angle as float
    Rotate as integer
    GoodNpcState as integer
    RotationTimer as integer = timer()
    path_start as integer
    target as path_Vector2
    path_end as integer
endtype

type ai_BadNpcType
    ObjNum as integer
    X as float
    Y as float
    Z as float
    Speed as float
    Distance as Float
    Angle as float
    Rotate as integer
    Direction as integer
    DistanceX as float
    DistanceZ as float
    RandomTimer as integer = timer()
    DirectionTimer as integer = timer()
    Health as integer
endtype

type ai_GoodNpcBulletType
    ObjNum as integer
    X as float
    Y as float
    Z as float
    Speed as float
    Distance as Float
    Distance2 as float
    Angle as float
    Rotate as float
    Alive as integer
    Direction as integer
    DistanceX as float
    DistanceZ as float
    DirectionTimer as integer = timer()
    Range as integer
endtype


/////////////////////////////////////////////////////////
// INIT                                                //
/////////////////////////////////////////////////////////


function initAI()

global goodNpcRange as float `Prefered player proximity
goodNpcRange = 450.0

global goodNpcRange2 as float
goodNpcRange2 = 300.0

global goodNpcRange3  as float
goodNpcRange3 = 300.0

global goodNpcRange4 as float
goodNpcRange4 = 1200.0

global badNpcRange as float
badNpcRange = 1200.0


rem just a bullet timer that tells how long to respawn a new bullet
global goodNpcBulletTime  as integer = timer()

global goodNpcs as integer
goodNpcs = 7
rem this is are name of are team mate npc type were going to use
dim goodNpc(goodNpcs) as ai_GoodNpcType

rem tells how many bad npcs were making
global badNpcs as integer
badNpcs = 7
rem we use badNpcs to give a value how many badNpcs are in the team
dim badNpc(badNpcs) as ai_BadNpcType

rem this is how many goodNpc bullets we have
global goodNpcBullets as integer
rem this is how many goodNpc bullets we have
goodNpcBullets = 7
rem we plug this value in are array so it tells us how many bullets were going to have
dim goodNpcBullet(goodNpcBullets) as ai_GoodNpcBulletType



for i = 0 to goodNpcs
   goodNpc(i).ObjNum = grabResource(res_Object)
rem this is are good npc position variable values
rem this spreads them out for now so they don't touch each other at the start
   goodNpc(i).X = -7+i*2
rem this moves them behind each other in a random fashion
   goodNpc(i).Z = 1000+rnd(600)
   goodNpc(i).Y = BT GetGroundHeight(g_Terrain_Main.dwTerrainID,goodNpc(i).X,goodNpc(i).Z)
rem this is are good npc speed how fast they will move first
   goodNpc(i).Speed = 180

   make object box  goodNpc(i).ObjNum,30,120,10
   color object goodNpc(i).ObjNum,rgb(0,0,255)
   position object  goodNpc(i).ObjNum,goodNpc(i).X,goodNpc(i).Y,goodNpc(i).Z
next i

for i = 0 to badNpcs
   badNpc(i).ObjNum = grabResource(res_Object)
rem this is are good npc position variable values
rem this spreads them out for now so they don't touch each other at the start
   badNpc(i).X = rnd(1000)
rem this moves them behind each other in a random fashion
   badNpc(i).Z = rnd(1000)
   badNpc(i).Y = BT GetGroundHeight(g_Terrain_Main.dwTerrainID,badNpc(i).X,badNpc(i).Z)
rem this is are good npc speed how fast they will move first
   badNpc(i).Speed = 180

   badNpc(i).Health = 1

   make object box  badNpc(i).ObjNum,30,120,10
   color object badNpc(i).ObjNum,rgb(255,0,0)
   position object  badNpc(i).ObjNum,badNpc(i).X,badNpc(i).Y,badNpc(i).Z
next i

for  i = 0 to goodNpcBullets
    goodNpcBullet(i).ObjNum = grabResource(res_Object)
rem  just give the bullets a very long position off the screen
    goodNpcBullet(i).X = 9999
    goodNpcBullet(i).Z = 9999
rem give the bullets some speed
    goodNpcBullet(i).Speed = 500
rem make are cube to represent are bullet
    make object cube goodNpcBullet(i).ObjNum,5
rem without this it wouldn't update the positions or rotations
    position object  goodNpcBullet(i).ObjNum,goodNpcBullet(i).X,goodNpcBullet(i).Y,goodNpcBullet(i).Z
next i


`Pathfinding
DIM path_Lines(0) as path_LineType
DIM path_Verts(0) as path_Vector2

DIM path_Paths(0) as path_Vector2

DIM PathingQueue(0) as integer

`TEMP
`Make some random boxes to path around.
for c=1 to 50
    temp=grabResource(res_Object)
    make object box temp,rnd(200),(400),rnd(200)
    position object temp,rnd(3000),200,rnd(3000)
    sc_setupobject temp,0,2
    sc_updateobject temp
    
    `Setup for pathing
    temp2=array count(path_Verts(0))
    array insert at bottom path_Verts(0)
    array insert at bottom path_Verts(0)
    array insert at bottom path_Verts(0)
    array insert at bottom path_Verts(0)
    
    path_Verts(temp2+1).X = object position x(temp)-object size x(temp)/2
    path_Verts(temp2+1).Y = object position y(temp)-object size y(temp)/2

    path_Verts(temp2+2).X = object position x(temp)+object size x(temp)/2
    path_Verts(temp2+2).Y = object position y(temp)-object size y(temp)/2

    path_Verts(temp2+3).X = object position x(temp)+object size x(temp)/2
    path_Verts(temp2+3).Y = object position y(temp)+object size y(temp)/2

    path_Verts(temp2+4).X = object position x(temp)-object size x(temp)/2
    path_Verts(temp2+4).Y = object position y(temp)+object size y(temp)/2
    
    array insert at top path_Lines(0)
    path_Lines(1).V1 = temp2+1
    path_Lines(1).V2 = temp2+2
    array insert at top path_Lines(0)
    path_Lines(1).V1 = temp2+2
    path_Lines(1).V2 = temp2+3
    array insert at top path_Lines(0)
    path_Lines(1).V1 = temp2+3
    path_Lines(1).V2 = temp2+4
    array insert at top path_Lines(0)
    path_Lines(1).V1 = temp2+4
    path_Lines(1).V2 = temp2+1
next c

`Process all the lines we made into a map for pathing
Path_ProcessData()

endfunction





function Path_ProcessData()

`Process distances
DIM path_Connections(0) as path_Connection
local DIM Connectiondels(0) as boolean

for c=1 to array count(path_Verts(0))
    
    for d=c+1 to array count(path_Verts(0))
        if Raycast(path_Verts(c).X,path_Verts(c).Y,path_Verts(d).X,path_Verts(d).Y,0,0)=0
            array insert at top path_Connections(0)
            array insert at top Connectiondels(0)
            path_Connections(1).V1=c
            path_Connections(1).V2=d
            path_Connections(1).Distance=SQRT((path_Verts(c).X-path_Verts(c).Y)^2+(path_Verts(c).Y-path_Verts(d).Y)^2)
        endif
    next d
next c

`Remove bad nodes (concave side)
for c=1 to array count(path_Verts(0))
    cv1=0
    cv2=0
    mode=0
    wrapped=0
    for d=1 to array count(path_Lines(0))
        if mode=0
            if path_Lines(d).V1=c then cv1=path_Lines(d).V2
            if path_Lines(d).V2=c then cv1=path_Lines(d).V1
            mode=1
            else
            if path_Lines(d).V1=c then cv2=path_Lines(d).V2
            if path_Lines(d).V2=c then cv2=path_Lines(d).V1
        endif
    next d
    
    if cv1>0 and cv2>0
    
        ang1#=wrapvalue(atanfull(path_Verts(cv1).X-path_Verts(c).X,path_Verts(cv1).Y-path_Verts(c).Y))
        ang2#=wrapvalue(atanfull(path_Verts(cv2).X-path_Verts(c).X,path_Verts(cv2).Y-path_Verts(c).Y))
        temp#=ang1#
        ang1#=max(ang1#,ang2#)
        ang2#=min(temp#,ang2#)
        if ang1#-ang2#>180 then wrapped=1
        
        for d=1 to array count(path_Connections(0))
            vtemp=0
            if path_Connections(d).V1=c then vtemp=path_Connections(d).V2
            if path_Connections(d).V2=c then vtemp=path_Connections(d).V1
    
            if vtemp>0
                angtemp#=wrapvalue(atanfull(path_Verts(vtemp).X-path_Verts(c).X,path_Verts(vtemp).Y-path_Verts(c).Y))
    
                bad=0
                if wrapped=1
                    if angtemp#>ang1# or angtemp#<ang2# then bad=1
                    else
                    if angtemp#<ang1# and angtemp#>ang2# then bad=1
                endif
                if bad=1 then connectiondels(d)=1
            endif
        
        next d
        
    endif
    
next c

`Delete
for c=array count(path_Connections(0)) to 1 step -1
    if Connectiondels(c)=1 then array delete element path_Connections(0),c
next c

UNDIM Connectondels(0)

endfunction


/////////////////////////////////////////////////////////
// CORE                                                //
/////////////////////////////////////////////////////////


function updateAI()

for i = 0 to goodNpcs

    `Move if we have a path
    if goodNpc(i).path_start>0
    
        goodNpcDistanceX = (goodNpc(i).X-goodNpc(i).Target.X)
        goodNpcDistanceZ = (goodNpc(i).Z-goodNpc(i).Target.Y)
        goodNpc(i).Angle = atanfull(goodNpcDistanceX,goodNpcDistanceZ)
        rem were setting are angle rule to move forward
        if wrapvalue(goodNpc(i).Angle) >= 90 and wrapvalue(goodNpc(i).Angle) <= 270
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed  * elapsedtime)
        endif
        rem were setting are angle rule to move backwards
        if wrapvalue(goodNpc(i).Angle) < 90 and wrapvalue(goodNpc(i).Angle) >=0
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed  * elapsedtime)
        endif
        rem were setting are angle rule to move backwards
        if wrapvalue(goodNpc(i).Angle) < 360 and wrapvalue(goodNpc(i).Angle) >= 270
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed  * elapsedtime)
        endif
        rem were setting are angle rule to move left
        if wrapvalue(goodNpc(i).Angle) >= 0 and wrapvalue(goodNpc(i).Angle) <= 180
         goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed  * elapsedtime)
        endif
        rem were setting are angle rule to move right
        if wrapvalue(goodNpc(i).Angle) >= 180 and wrapvalue(goodNpc(i).Angle) <= 360
        goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed  * elapsedtime)
        endif
        rem updates angles so it works
        yrotate object goodNpc(i).ObjNum,goodNpc(i).Angle

        `Switch to next pathing point if necessary
        if near(goodNpc(i).X,path_Paths(goodNpc(i).Path_Start).X) and near(goodNpc(i).Y,path_Paths(goodNpc(i).Path_Start).Y)
            array delete element path_Paths(0),goodNpc(i).Path_Start
            dec goodNpc(i).Path_End
            for d=1 to array count(goodNpc(0))
                if d<>i and goodNpc(d).Path_Start>goodNpc(i).Path_Start
                    dec goodNpc(d).Path_Start
                    dec goodNpc(d).Path_End
                endif
            next d
            if goodNpc(i).Path_Start>goodNpc(i).Path_End then goodNpc(i).Path_Start=0 : goodNpc(i).Path_End=0
        endif
        
    endif
    
    ///////////////////////////
    // The thinking part
    // AI decides how to path
    
    if goodNpc(i).path_start=0
        
        `follow the player
        if goodNpc(i).goodNpcState = 0
            if goodNpc(i).Distance > goodNpcRange
            
                `Now, we add the NPC to the pathing queue to go to the player's position
                array insert at bottom PathingQueue(0)
                PathingQueue(array count(PathingQueue(0)))=i
                goodNpc(i).Target.X = PLR_footpos.x
                goodNpc(i).Target.Y = PLR_footpos.z
            
            endif
        endif
    
        `scout the area for enemies
        if goodNpc(i).goodNpcState = 1
            `We now pick a random point near the player and path to it
            array insert at bottom PathingQueue(0)
            PathingQueue(array count(PathingQueue(0)))=i
            
            goodNpc(i).Target.X=rnd(300)-150+PLR_footpos.x
            goodNpc(i).Target.Y=rnd(300)-150+PLR_footpos.z
        endif
        
        `attack mode
            `if badNpc the enemy is in sight point at the enemy
            `and move around randomly while pointing at the enemy this is attack mode
        if goodNpc(i).goodNpcState = 2
            `We now pick a random point near the player and path to it
            array insert at bottom PathingQueue(0)
            PathingQueue(array count(PathingQueue(0)))=i
            
            goodNpc(i).Target.X=rnd(300)-150+PLR_footpos.x
            goodNpc(i).Target.Y=rnd(300)-150+PLR_footpos.z
            
            for j = 0 to  badNpcs-i
                DistanceX2 = (goodNpc(i).X-badNpc(j).X)
                rem were getting the point betwween the goodNpc z, and player z
                DistanceZ2 = (goodNpc(i).Z-badNpc(j).Z)
                rem we then put are formula's in the atanfull to get the angle between to objects
                goodNpc(i).Angle = atanfull(DistanceX2 ,DistanceZ2)
                yrotate object goodNpc(i).ObjNum,goodNpc(i).Angle
            next j
            GoodNpc_Fire_Bullet(i)
        endif
    
    endif

    `Check distances and stuff
    if goodNpc(i).Distance > goodNpcRange
        `follow the player
        goodNpc(i).goodNpcState = 0
    endif
    
    if goodNpc(i).Distance < goodNpcRange and goodNpc(i).Distance > goodNpcRange2
        `scout the area, and move random, then look around for bad guys
        goodNpc(i).goodNpcState = 1
    endif
    
    if goodNpc(i).Distance2 < goodNpcRange4 and goodNpc(i).Distance < goodNpcRange
        `if a badNoc is around attack, and fire at them
        goodNpc(i).goodNpcState = 2
        else
        
        if goodNpc(i).Distance2 > goodNpcRange4 and goodNpc(i).Distance < goodNpcRange
            `return to scout mode
            goodNpc(i).goodNpcState = 1
        endif
    endif
   
    rem we make are distance formulas
    for j = 0 to badNpcs-i
        rem make this distance formula, because we need this to point the blue team at the player
        goodNpc(i).Distance = sqrt((goodNpc(i).X-PLR_footpos.X)^2+(goodNpc(i).Z-PLR_footpos.Z)^2)
        rem make this distance formula, because it's needed for the red team to  point at the blue team.
        goodNpc(i).Distance2 = sqrt((goodNpc(i).X-badNpc(j).X)^2+(goodNpc(i).Z-badNpc(j).Z)^2)
    next j
    
    rem without this it wouldn't update the positions or rotations
    position object goodNpc(i).ObjNum,goodNpc(i).X,60+BT GetGroundHeight(g_Terrain_Main.dwTerrainID,goodNpc(i).X,goodNpc(i).Z),goodNpc(i).Z
next i


`DEBUG
for c=1 to array count(path_Paths(0))
    text 10,c*10,str$(path_Paths(c).X)+","+str$(path_Paths(c).Y)
next c
for c=1 to array count(goodNpc(0))
    text 100,goodNpc(c).Path_Start*10,str$(c)
    text 100,goodNpc(c).Path_End*10,"/"+str$(c)
next c

text 600,10,str$(PLR_footpos.x)+","+str$(PLR_footpos.z)



for i = 0 to goodNpcBullets
rem move the bullet
   GoodNpc_Move_Bullet(i)
rem get are distance formulas
   GoodNpc_Bullet_Distance_Formulas(i)
rem make sure are bullet stays inbounds
   GoodNpc_Bullet_Stay_Inbounds(i)
  `GoodNpcBullet_Point_At_BadNpc()
rem updates all the goodNpcBullet position , and rotation
  yrotate object goodNpcBullet(i).ObjNum,goodNpcBullet(i).Angle
  position object goodNpcBullet(i).ObjNum,goodNpcBullet(i).X,goodNpcBullet(i).Y,goodNpcBullet(i).Z
next i


rem note I didn't add no ai states in the bad npc, so the code is just there
for i = 0 to badNpcs
rem this moves the bad npc randomly
 BadNpc_Npc_Move_Random(i)
rem this makes sure the bad npc stays inbounds
 BadNpc_Npc_Stay_Inbounds(i)
  `BadNpc_Point_At_GoodNpc(i)
rem this is are bad npc distance formulas
 BadNpc_Distance_Formulas(i)
rem this tells us if a bad npc is dead respawn it
 BadNpc_Respawn(i)
rem without this it wouldn't update the positions or rotations
  yrotate object badNpc(i).ObjNum,badNpc(i).Angle
  position object badNpc(i).ObjNum,badNpc(i).X,60+BT GetGroundHeight(g_Terrain_Main.dwTerrainID,badNpc(i).X,badNpc(i).Z),badNpc(i).Z
next i


`Run pathing queue
if array count(PathingQueue(0))>0
    goodNpc(PathingQueue(1)).path_start=array count(path_Paths(0))+1
    Path(goodNpc(PathingQueue(1)).X,goodNpc(PathingQueue(1)).Y,goodNpc(PathingQueue(1)).Target.X,goodNpc(PathingQueue(1)).Target.Y)
    goodNpc(PathingQueue(1)).path_end=array count(path_Paths(0))
    array delete element PathingQueue(0),1
endif


endfunction





function GoodNpc_Bullet_Distance_Formulas(i as integer)
rem we use are distance formulas here
   for j = 0 to badNpcs-i
rem make a distance formula
      goodNpcBullet(i).Distance = sqrt((goodNpcBullet(i).X-badNpc(j).X)^2+(goodNpcBullet(i).Z-badNpc(j).Z)^2)
rem if distance is less then 1 then a collision toke place, and
rem killed a red BadNpc team mate
      if goodNpcBullet(i).Distance < 1
rem we now set the bullet to not alive, so bullet is now dead
         goodNpcBullet(i).Alive = 0
rem if bullet is dead then position the bullets far off
         goodNpcBullet(i).X = - 9999
         goodNpcBullet(i).Z = - 9999
rem decrease Health by 1
         badNpc(j).Health = badNpc(j).Health - 1
rem if Health is less then  or equal to 0 then make sure Health doesn't go below 0
         if badNpc(j).Health <= 0 then badNpc(j).Health = 0
rem we now hide the object, because the bullet is dead
         hide object goodNpcBullet(i).ObjNum
      endif
   next j
endfunction


function GoodNpc_Bullet_Respawn()
rem this is how to make a bullet respawn
rem use this local variable to do something cool
   goodNpcBulletRespawn as integer

   for j = 0 to goodNpcs
rem we use this method i = i + 1 if i greater then are bullets then i = 0
rem tells us to start over, and keep checking through are array
       i = i + 1
       if i > goodNpcBullets then i = 0
rem if goodNpcBulletRespawn equals 0 and Bullet Alive = 0
       if goodNpcBulletRespawn = 0 and goodNpcBullet(i).Alive = 0
rem bullet alive = 1, because we found a bullet
          goodNpcBullet(i).Alive = 1
rem Range = 0 to set this, so if the bullet doesn't hit a bad guy
rem we use a counter to kill the bullet if not the bullet keeps going
          goodNpcBullet(i).Range = 0
rem give the bullet position the goodNpc position
          goodNpcBullet(i).X = goodNpc(j).X
          goodNpcBullet(i).Z = goodNpc(j).Z
rem now we point are bullet at the bad npc
          `GoodNpcBullet_Point_At_BadNpc(i)
rem we show the bullet
          show object goodNpcBullet(i).ObjNum
rem goodNpcBulletRespawn = 1 what this does it makes sure it only grabs 1 bullet at a time
rem so we don't get any bugs that's why I needed that local variable there
          goodNpcBulletRespawn = 1
       endif
   next j
endfunction

function GoodNpc_Move_Bullet(i as integer)
rem we now move are goodNpc bullet
rem if bullet Alive equals 1 then start moving the bullet
   if goodNpcBullet(i).Alive = 1
rem this is are counter Range start increasing its value
      goodNpcBullet(i).Range = goodNpcBullet(i).Range + 1
rem this moves are bullet at the angle of are bad npc and uses the old position so
rem the angle doesn't update like a missle following the bad npc
      goodNpcBullet(i).X = goodNpcBullet(i).X - ( sin( wrapvalue(goodNpcBullet(i).Angle ) ) *  goodNpcBullet(i).Speed  * elapsedtime)
      goodNpcBullet(i).Z = goodNpcBullet(i).Z - ( cos( wrapvalue(goodNpcBullet(i).Angle ) ) *  goodNpcBullet(i).Speed  * elapsedtime)
   endif
endfunction

function GoodNpc_Bullet_Stay_Inbounds(i as integer)
rem this makes sure are bullet stays inbounds
rem like frome xample if bullet doesn't hit a bad guy it keeps going so we
rem must tell it to destroy the bullet if it does hit a bad guy
   for j = 0 to goodNpcs-i
rem bullet is alive
      if goodNpcBullet(i).Alive = 1
rem are counter which is Range is greater then 80 bullet dies
         if goodNpcBullet(i).Range > 80
rem we set bullet alive to 0, and range to 0
            goodNpcBullet(i).Alive = 0
            goodNpcBullet(i).Range = 0
rem we position the bullet back at goodNpc
            goodNpcBullet(i).X = goodNpc(j).X
            goodNpcBullet(i).Z = goodNpc(j).Z
rem we hide the buller because its destroyed
            hide object goodNpcBullet(i).ObjNum
         endif
      endif
   next j
endfunction


function GoodNpc_Bullet_Collision(i as integer)
rem we use this to detect if it its a bad guy
   for j = 0 to badNpcs-i
rem if distance is less then 1 then we have a collision with a bad npc
         if goodNpcBullet(i).Distance < 1
rem kill bullet
            goodNpcBullet(i).Alive = 0
rem reset are counter to range to 0
            goodNpcBullet(i).Range = 0
rem if bullet is dead
            if goodNpcBullet(i).Alive = 0
rem decrease health by 1, and make sure health doesn't go below 0
               `badNpc(j).Health = badNpc(j).Health - 1
               `if badNpc(j).Health <= -1 then badNpc(j).Health = 0
rem hide object because bullet is dead
               hide object goodNpcBullet(i).ObjNum
            endif
         endif
rem if Health = 0 then the bad npc is dead
         `if badNpc(j).Health = 0
rem just move the bad npc out of the way
           ` badNpc(j).X = -9999
           ` badNpc(j).Z = -9999
        ` endif
   next j
endfunction

function GoodNpc_Fire_Bullet(i as integer)
rem make a timer each 200 millisecond's get a new bullet
      if timer()-goodNpcBulletTime> 200
rem we respawn the bullet
         GoodNpc_Bullet_Respawn()
rem update the timer so it works
         goodNpcBulletTime = timer()
      endif
endfunction


function BadNpc_Respawn(i as integer)
rem if health  = 0 then respawn the bad npc
   if badNpc(i).Health = 0
rem give the bad npc health so there alive again
      badNpc(i).Health = 1
rem position the bad npc at a random location
      badNpc(i).X = -rnd(30)+rnd(30)
      badNpc(i).Z = -rnd(30)+rnd(30)
   endif
endfunction

function BadNpc_Npc_Move_Random(i as integer)
rem this tells the bad npcs which way to move
rem if direction = 1 move forward
if badNpc(i).Direction = 1 then badNpc(i).Z = badNpc(i).Z + badNpc(i).Speed * elapsedtime
rem if direction = 2 move backwards
if badNpc(i).Direction = 2 then badNpc(i).Z = badNpc(i).Z - badNpc(i).Speed * elapsedtime
rem if direction = 3 move right
if badNpc(i).Direction = 3 then badNpc(i).X = badNpc(i).X + badNpc(i).Speed * elapsedtime
rem if direction = 4 move left
if badNpc(i).Direction = 4 then badNpc(i).X = badNpc(i).X - badNpc(i).Speed * elapsedtime
rem we make a timer to say each 2000 milliseconds change the bad npcs direction
   if timer()-badNpc(i).RandomTimer > 2000
rem pick a random direction
      badNpc(i).Direction = rnd(3)+1
rem update the timer so it works
      badNpc(i).RandomTimer = timer()
   endif
endfunction

function BadNpc_Distance_Formulas(i as integer)
rem this is are badnpcs distance formulas
   for j = 0 to goodNpcs-i
rem this gets the distance from the bad npcs to the good npcs
      badNpc(i).Distance = sqrt((badNpc(i).X-goodNpc(j).X)^2+(badNpc(i).Z-goodNpc(j).Z)^2)
rem this points the bad npcs at the good npcs if its less then badNpcRange
      if badNpc(i).Distance <  badNpcRange
rem point at the good npcs
         BadNpc_Point_At_GoodNpc(i)
      endif
   next j
endfunction


function BadNpc_Npc_Stay_Inbounds(i as integer)

rem this is are tempary stay in bounds area
rem if bad npc goes farther than 30
rem  then change the bad npc direction, so the bad npc goes left
if badNpc(i).X > 2000
rem make the bad npc go left
    badNpc(i).Direction = 4
endif
rem if bad npc goes less than -30
rem  then change the bad npc direction, so the bad npc goes right
if badNpc(i).X < 0
rem make the bad npc go right
    badNpc(i).Direction = 3
endif
rem if bad npc goes farther than 30
rem  then change the bad npc direction, so the bad npc goes backwards
if badNpc(i).Z > 2000
rem makes the bad npc to backwards
    badNpc(i).Direction = 2
endif
rem if bad npc goes less than -30
rem  then change the bad npc direction, so the bad npc goes forward
if badNpc(i).Z < 0
rem makes the bad npc to forward
    badNpc(i).Direction = 1
endif

endfunction

function BadNpc_Point_At_GoodNpc(i as integer)
rem this is how we point the goodNpc at the player
rem this is 10X faster then point object, so this gives us better performance
rem were getting the point between the badNpc, and goodNpc
   for j = 0 to  goodNpcs-i
rem were getting the point betwween the badNpc x, and goodNpc x
       badNpc(i).DistanceX = (badNpc(i).X-goodNpc(j).X)
rem were getting the point betwween the badNpc z, and goodNpc z
      badNpc(i).DistanceZ = (badNpc(i).Z-goodNpc(j).Z)
rem we then put are formula's in the atanfull to get the angle between to objects
       badNpc(i).Angle = atanfull(badNpc(i).DistanceX ,badNpc(i).DistanceZ)
    next j
endfunction


function GoodNpcBullet_Point_At_BadNpc(i as integer)
rem this is how we point the goodNpcBullet at the badNpc
rem this is 10X faster then point object, so this gives us better performance
rem were getting the point betwween the goodNpcBullet, and badNpc
    for j = 0 to badNpcs-i
rem were getting the point betwween the goodNpcBullet x, and badNpc x
      goodNpcBullet(i).DistanceX = (goodNpcBullet(i).X-badNpc(j).X)
rem were getting the point betwween the goodNpcBullet x, and badNpc x
      goodNpcBullet(i).DistanceZ = (goodNpcBullet(i).Z-badNpc(j).Z)
rem were getting the point betwween the
rem we then put are formula's in the atanfull to get the angle between to objects
      goodNpcBullet(i).Angle = atanfull(goodNpcBullet(i).DistanceX ,goodNpcBullet(i).DistanceZ)
    next j
endfunction

function Debugg_Program()
rem all debugg goes here
rem shows the ai modes
   for  i= 0 to goodNpcs
      if goodNpc(i).goodNpcState = 0
         text 20,20*i,"goodNpc "+str$(i)+" No threat Mode: "`+str$(goodNpc(i).goodNpcState)
      endif

      if goodNpc(i).goodNpcState = 1
         text 20,20*i,"goodNpc "+str$(i)+" Scout Mode: "`+str$(goodNpc(i).goodNpcState)
      endif

      if goodNpc(i).goodNpcState = 2
         text 20,20*i,"goodNpc "+str$(i)+ " Attack Mode: "`+str$(goodNpc(i).goodNpcState)
      endif
   next i

endfunction


////////// PATHING /////////////
function Path(StartX,StartY,EndX,EndY)

UNDIM TempNodes(0)
local DIM TempNodes(array count(path_Verts(0))) as path_AStarNode

`Straight line path exemption
`If there is a direct path, don't bother pathfinding!
if Raycast(StartX,StartY,EndX,EndY,0,0)=0
    array insert at bottom path_Paths(0)
    path_Paths(array count(path_Paths(0))).X=EndX
    path_Paths(array count(path_Paths(0))).Y=EndY
    exitfunction
endif

`Set any nodes visible from start location to "Open"
for c=1 to array count(path_Verts(0))
    if Raycast(StartX,StartY,path_Verts(c).X,path_Verts(c).Y,0,0)=0
        TempNodes(c).Open=1
        TempNodes(c).Parent=0
        TempNodes(c).G=SQRT((StartX-path_Verts(c).X)^2+(StartY-path_Verts(c).y)^2)
        TempNodes(c).H=abs(StartX-path_Verts(c).X)+abs(StartY-path_Verts(c).y)
        TempNodes(c).F=TempNodes(c).G+TempNodes(c).H
    endif
next c

`While we can't see the destination...
while Raycast(path_Verts(winner).X,path_Verts(winner).Y,EndX,EndY,0,0)=1 or winner=0

    `Find the open node with the lowest score
    score=99999
    winner=0
    for c=1 to array count(TempNodes(0))
        if TempNodes(c).Open=1 and TempNodes(c).Closed=0
            if TempNodes(c).F<score
                winner=c
                score=TempNodes(c).F
            endif
        endif
    next c
    
    `If we didn't find any open nodes, we're stuck.  Quit and blacklist.
    if winner=0 then exitfunction
    
    TempNodes(winner).Closed=1
    
    `Open any nodes visible from the one we found above
    for c=1 to array count(path_Connections(0))
        temp=0
        if path_Connections(c).V1=winner then temp=path_Connections(c).V2
        if path_Connections(c).V2=winner then temp=path_Connections(c).V1
        
        `Make sure this doesn't cross through the vertex
        if temp>0 `Angle stuff
            if TempNodes(temp).Open=0
                TempNodes(temp).Open=1
                TempNodes(temp).Parent=winner
                TempNodes(temp).G=TempNodes(winner).G+path_Connections(c).Distance
                TempNodes(temp).H=abs(path_Verts(winner).X-path_Verts(temp).X)+abs(path_Verts(winner).Y-path_Verts(temp).y)
                TempNodes(temp).F=TempNodes(temp).G+TempNodes(temp).H
                else
                if TempNodes(temp).G>TempNodes(winner).G+path_Connections(c).Distance
                    TempNodes(temp).Parent=winner
                    TempNodes(temp).G=TempNodes(winner).G+path_Connections(c).Distance
                    TempNodes(temp).F=TempNodes(temp).G+TempNodes(temp).H
                endif
            endif                    
        endif
    next c

endwhile

`Backtrack to find path
if winner>0
    repeat
        array insert at top path_Paths(0)
        path_Paths(1).X=path_Verts(winner).X
        path_Paths(1).Y=path_Verts(winner).Y
        winner=TempNodes(winner).Parent
    until winner=0
endif

array insert at bottom path_Paths(0)
path_Paths(array count(path_Paths(0))).X=EndX
path_Paths(array count(path_Paths(0))).Y=EndY

endfunction




function Raycast(X1 as integer,Y1 as integer,X2 as integer,Y2 as integer,NL1,NL2)
for c=1 to array count(path_Lines(0))
    if c<>NL1 and c<>NL2
        if FastLineIntersection(X1,Y1,X2,Y2,path_Verts(path_Lines(c).V1).X,path_Verts(path_Lines(c).V1).Y,path_Verts(path_Lines(c).V2).X,path_Verts(path_Lines(c).V2).Y) then exitfunction 1
    endif
next c
endfunction 0


`by IanM
function FastLineIntersection(Ax as float,Ay as float,Bx as float,By as float,Cx as float,Cy as float,Dx as float,Dy as float)
local r as float : local s as float : local d as float : local n as float
n = ((Ay - Cy) * (Dx - Cx)) - ((Ax - Cx) * (Dy - Cy))
d = ((Bx - Ax) * (Dy - Cy)) - ((By - Ay) * (Dx - Cx))
if d = 0 then exitfunction 0
r = n / d
s = ( ((Ay-Cy)*(Bx-Ax))-((Ax-Cx)*(By-Ay)) ) / d
if r <= 0 then exitfunction 0
if r >= 1 then exitfunction 0
if s <= 0 then exitfunction 0
if s >= 1 then exitfunction 0
endfunction 1


function near(a#,b#)
temp#=30.0
if a#+temp#>b# and a#-temp#<b# or b#+temp#>a# and b#-temp#<a# then exitfunction 1
endfunction 0


/////////////////////////////////////////////////////////
// TERMINATE                                           //
/////////////////////////////////////////////////////////


function terminateAI()

for i=0 to array count(goodNpc(0))
    freeResource(goodNpc(i).ObjNum,res_Object)
next i
UNDIM goodNpc(0)

for i=0 to array count(badNpc(0))
    freeResource(badNpc(i).ObjNum,res_Object)
next i
UNDIM badNpc(0)

for i=0 to array count(goodNpcBullet(0))
    freeResource(goodNpcBullet(i).ObjNum,res_Object)
next i
UNDIM goodNpcBullet(0)

endfunction