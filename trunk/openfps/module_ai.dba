Rem ***** Included Source File *****
/////////////////////////
//
// OpenFPS AI Mechanics Module
//
// Created by darkvee
//   Pathfinding by BMacZero
// Maintained by darkvee
//
/////////////////////////////////////////////////////

----- Changelog:
(2/8/10) - BMacZero - Created
(2/28/10) - BMacZero - Incorporated darkvee's code
(3/7/10) - BMacZero - Started adding my pathfinding
(4/16/10) - BMac - More pathing work
(6/27/10) - miso - Just repositioned the debugger info displayed on screen, to give space for the appearing console
(7/4/10)  - miso - placed 4 log commands


----- To-Do:
Replace goodNPC state 2 with cover system
Synchronize with module_shooting

----- Purpose:
This module handles all pathfinding and decision-
making for any non-player characters in the game.

If the NPCs choose to shoot or use a similar ability,
this module tells the appropriate module to take care
of it.


----- Dependancies and Conflicts (IMPORTANT STUFF):
-None-


----- Other Notes:



remend



`global timerBasedTimer as integer = timer()


`Pathfinding
type path_Vector2
    X as float
    Y as float
endtype

type path_LineType
    V1 as integer
    V2 as integer
endtype

type path_AStarNode
    F as integer
    G as integer
    H as integer
    Open as boolean
    Closed as boolean
    Parent as integer
endtype

type path_Connection
    V1 as integer
    V2 as integer
    Distance as integer
endtype



type ai_GoodNpcType
    ObjNum as integer
    X as float
    Y as float
    Z as float
    Speed as float
    Distance as Float
    Distance2 as float
    DistanceX as float
    DistanceZ as float
    Angle as float
    Rotate as integer
    GoodNpcState as integer
    RotationTimer as integer = timer()
    path_start as integer
    target as path_Vector2
    path_end as integer
endtype

type ai_BadNpcType
    ObjNum as integer
    X as float
    Y as float
    Z as float
    Speed as float
    Distance as Float
    Angle as float
    Rotate as integer
    Direction as integer
    DistanceX as float
    DistanceZ as float
    RandomTimer as integer = timer()
    DirectionTimer as integer = timer()
    Health as integer
endtype


/////////////////////////////////////////////////////////
// INIT                                                //
/////////////////////////////////////////////////////////


function initAI()
UI_WriteLog(UI_Green,"=== Starting AI module")

global goodNpcRange as float `Prefered player proximity
goodNpcRange = 500.0

global goodNpcRange2 as float `Where npc abandons "follow player"
goodNpcRange2 = 200.0

global goodNpcRange3  as float
goodNpcRange3 = 300.0

global goodNpcRange4 as float
goodNpcRange4 = 1200.0

global badNpcRange as float
badNpcRange = 1200.0


global goodNpcs as integer
goodNpcs = 0
rem this is are name of are team mate npc type were going to use
dim goodNpc(goodNpcs) as ai_GoodNpcType

rem tells how many bad npcs were making
global badNpcs as integer
badNpcs = -1
rem we use badNpcs to give a value how many badNpcs are in the team
dim badNpc(badNpcs) as ai_BadNpcType



for i = 0 to goodNpcs
   goodNpc(i).ObjNum = grabResource(res_Object)
rem this is are good npc position variable values
rem this spreads them out for now so they don't touch each other at the start
   goodNpc(i).X = rnd(1000)
rem this moves them behind each other in a random fashion
   goodNpc(i).Z = 1000+rnd(600)
   goodNpc(i).Y = BT GetGroundHeight(g_Terrain_Main.dwTerrainID,goodNpc(i).X,goodNpc(i).Z)
rem this is are good npc speed how fast they will move first
   goodNpc(i).Speed = 180

   make object box  goodNpc(i).ObjNum,30,120,10
   color object goodNpc(i).ObjNum,rgb(0,0,255)
   position object  goodNpc(i).ObjNum,goodNpc(i).X,goodNpc(i).Y,goodNpc(i).Z
next i

for i = 0 to badNpcs
   badNpc(i).ObjNum = grabResource(res_Object)
rem this is are good npc position variable values
rem this spreads them out for now so they don't touch each other at the start
   badNpc(i).X = rnd(1000)
rem this moves them behind each other in a random fashion
   badNpc(i).Z = rnd(1000)
   badNpc(i).Y = BT GetGroundHeight(g_Terrain_Main.dwTerrainID,badNpc(i).X,badNpc(i).Z)
rem this is are good npc speed how fast they will move first
   badNpc(i).Speed = 180

   badNpc(i).Health = 1

   make object box  badNpc(i).ObjNum,30,120,10
   color object badNpc(i).ObjNum,rgb(255,0,0)
   position object  badNpc(i).ObjNum,badNpc(i).X,badNpc(i).Y,badNpc(i).Z
next i


`Pathfinding
DIM path_Lines(0) as path_LineType
DIM path_Verts(0) as path_Vector2

DIM path_Paths(0) as path_Vector2

DIM PathingQueue(0) as integer

`TEMP
`Make some random boxes to path around.
for c=1 to 50
    temp=grabResource(res_Object)
    tempx=rnd(3000)
    tempy=rnd(3000)
    make object box temp,rnd(200),(400),rnd(200)
    position object temp,tempx,200,tempy
    sc_setupobject temp,0,2
    sc_updateobject temp
    
    `Setup for pathing
    temp2=array count(path_Verts(0))
    array insert at bottom path_Verts(0)
    array insert at bottom path_Verts(0)
    array insert at bottom path_Verts(0)
    array insert at bottom path_Verts(0)
    
    path_Verts(temp2+1).X = tempx-object size x(temp)/2
    path_Verts(temp2+1).Y = tempy-object size z(temp)/2

    path_Verts(temp2+2).X = tempx+object size x(temp)/2
    path_Verts(temp2+2).Y = tempy-object size z(temp)/2

    path_Verts(temp2+3).X = tempx+object size x(temp)/2
    path_Verts(temp2+3).Y = tempy+object size z(temp)/2

    path_Verts(temp2+4).X = tempx-object size x(temp)/2
    path_Verts(temp2+4).Y = tempy+object size z(temp)/2
    
    temp3=array count(path_Lines(0))
    array insert at bottom path_Lines(0)
    array insert at bottom path_Lines(0)
    array insert at bottom path_Lines(0)
    array insert at bottom path_Lines(0)
    
    path_Lines(temp3+1).V1 = temp2+1
    path_Lines(temp3+1).V2 = temp2+2
    
    path_Lines(temp3+2).V1 = temp2+2
    path_Lines(temp3+2).V2 = temp2+3
    
    path_Lines(temp3+3).V1 = temp2+3
    path_Lines(temp3+3).V2 = temp2+4
    
    path_Lines(temp3+4).V1 = temp2+4
    path_Lines(temp3+4).V2 = temp2+1
next c

`Process all the lines we made into a map for pathing
Path_ProcessData()
UI_WriteLog(UI_Green,"=== AI module started")
endfunction





function Path_ProcessData()

`Process distances
DIM path_Connections(0) as path_Connection
local DIM Connectiondels(0) as boolean

for c=1 to array count(path_Verts(0))
    
    for d=c+1 to array count(path_Verts(0))
        if Raycast(path_Verts(c).X,path_Verts(c).Y,path_Verts(d).X,path_Verts(d).Y,0,0)=0
            array insert at top path_Connections(0)
            array insert at top Connectiondels(0)
            path_Connections(1).V1=c
            path_Connections(1).V2=d
            path_Connections(1).Distance=SQRT((path_Verts(c).X-path_Verts(c).Y)^2+(path_Verts(c).Y-path_Verts(d).Y)^2)
        endif
    next d
next c

`Remove bad nodes (concave side)
for c=1 to array count(path_Verts(0))
    cv1=0
    cv2=0
    mode=0
    wrapped=0
    for d=1 to array count(path_Lines(0))
        if mode=0
            if path_Lines(d).V1=c then cv1=path_Lines(d).V2
            if path_Lines(d).V2=c then cv1=path_Lines(d).V1
            mode=1
            else
            if path_Lines(d).V1=c then cv2=path_Lines(d).V2
            if path_Lines(d).V2=c then cv2=path_Lines(d).V1
        endif
    next d
    
    if cv1>0 and cv2>0
    
        ang1#=wrapvalue(atanfull(path_Verts(cv1).X-path_Verts(c).X,path_Verts(cv1).Y-path_Verts(c).Y))
        ang2#=wrapvalue(atanfull(path_Verts(cv2).X-path_Verts(c).X,path_Verts(cv2).Y-path_Verts(c).Y))
        temp#=ang1#
        ang1#=max(ang1#,ang2#)
        ang2#=min(temp#,ang2#)
        if ang1#-ang2#>180 then wrapped=1
        
        for d=1 to array count(path_Connections(0))
            vtemp=0
            if path_Connections(d).V1=c then vtemp=path_Connections(d).V2
            if path_Connections(d).V2=c then vtemp=path_Connections(d).V1
    
            if vtemp>0
                angtemp#=wrapvalue(atanfull(path_Verts(vtemp).X-path_Verts(c).X,path_Verts(vtemp).Y-path_Verts(c).Y))
    
                bad=0
                if wrapped=1
                    if angtemp#>ang1# or angtemp#<ang2# then bad=1
                    else
                    if angtemp#<ang1# and angtemp#>ang2# then bad=1
                endif
                if bad=1 then connectiondels(d)=1
            endif
        
        next d
        
    endif
    
next c

`Delete
for c=array count(path_Connections(0)) to 1 step -1
    if Connectiondels(c)=1 then array delete element path_Connections(0),c
next c

UNDIM Connectondels(0)

endfunction


/////////////////////////////////////////////////////////
// CORE                                                //
/////////////////////////////////////////////////////////


function updateAI()

for i = 0 to goodNpcs

    `Move if we have a path
    if goodNpc(i).path_start>0
    
        goodNpcDistanceX = (goodNpc(i).X-path_Paths(goodNpc(i).path_start).X)
        goodNpcDistanceZ = (goodNpc(i).Z-path_Paths(goodNpc(i).path_start).Y)
        goodNpc(i).Angle = atanfull(goodNpcDistanceX,goodNpcDistanceZ)

        goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed  * elapsedtime)
        goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed  * elapsedtime)
        
        rem updates angles so it works
        yrotate object goodNpc(i).ObjNum,goodNpc(i).Angle

        `Switch to next pathing point if necessary
        if near(object position x(goodNpc(c).ObjNum),path_Paths(goodNpc(i).Path_Start).X) and near(object position z(goodNpc(c).ObjNum),path_Paths(goodNpc(i).Path_Start).Y)
            array delete element path_Paths(0),goodNpc(i).path_start
            dec goodNpc(i).path_end
            for d=1 to array count(goodNpc(0))
                if d<>i and goodNpc(d).path_start>goodNpc(i).path_start
                    dec goodNpc(d).path_start
                    dec goodNpc(d).path_end
                endif
            next d
            if goodNpc(i).Path_Start>goodNpc(i).Path_End then goodNpc(i).Path_Start=0 : goodNpc(i).Path_End=0 : goodNpc(i).Target.X=0
        endif
        
    endif
    
    ///////////////////////////
    // The thinking part
    // AI decides how to path
    
    rem we make our distance formulas
    goodNpc(i).Distance = sqrt((goodNpc(i).X-PLR_footpos.X)^2+(goodNpc(i).Z-PLR_footpos.Z)^2)
    for j = 0 to badNpcs-i
        rem make this distance formula, because it's needed for the red team to  point at the blue team.
        goodNpc(i).Distance2 = sqrt((goodNpc(i).X-badNpc(j).X)^2+(goodNpc(i).Z-badNpc(j).Z)^2)
    next j
    
    `UI_text(1,10,110+UI_EVENT_ConsoleOffset,"Distance:"+str$(goodNpc(i).Distance))
    
    `Find new target if have none
    if goodNpc(i).Target.X=0
        
        `follow the player
        if goodNpc(i).goodNpcState = 0
            if goodNpc(i).Distance > goodNpcRange
                `Now, we add the NPC to the pathing queue to go to the player's position
                array insert at bottom PathingQueue(0)
                PathingQueue(array count(PathingQueue(0)))=i
                goodNpc(i).Target.X = PLR_footpos.x
                goodNpc(i).Target.Y = PLR_footpos.z
            endif
        endif
    
        `scout the area for enemies
        remstart
        if goodNpc(i).goodNpcState = 1
            `We now pick a random point near the player and path to it
            array insert at bottom PathingQueue(0)
            PathingQueue(array count(PathingQueue(0)))=i
            
            goodNpc(i).Target.X=rnd(300)-150+PLR_footpos.x
            goodNpc(i).Target.Y=rnd(300)-150+PLR_footpos.z
        endif
        remend
        
        remstart
        `attack mode
            `if badNpc the enemy is in sight point at the enemy
            `and move around randomly while pointing at the enemy this is attack mode
        if goodNpc(i).goodNpcState = 2
            `We now pick a random point near the player and path to it
            array insert at bottom PathingQueue(0)
            PathingQueue(array count(PathingQueue(0)))=i
            
            goodNpc(i).Target.X=rnd(300)-150+PLR_footpos.x
            goodNpc(i).Target.Y=rnd(300)-150+PLR_footpos.z
            
            for j = 0 to  badNpcs-i
                DistanceX2 = (goodNpc(i).X-badNpc(j).X)
                rem were getting the point betwween the goodNpc z, and player z
                DistanceZ2 = (goodNpc(i).Z-badNpc(j).Z)
                rem we then put are formula's in the atanfull to get the angle between to objects
                goodNpc(i).Angle = atanfull(DistanceX2 ,DistanceZ2)
                yrotate object goodNpc(i).ObjNum,goodNpc(i).Angle
            next j
        endif
        remend
    
    endif

    `Check distances and stuff
    if goodNpc(i).Distance > goodNpcRange
        `follow the player
        goodNpc(i).goodNpcState = 0
    endif
    
    if goodNpc(i).Distance < goodNpcRange
        `scout the area, and move random, then look around for bad guys
        goodNpc(i).goodNpcState = 1
    endif
    
    if goodNpc(i).Distance2 < goodNpcRange4 and goodNpc(i).Distance < goodNpcRange
        `if a badNoc is around attack, and fire at them
        goodNpc(i).goodNpcState = 2
        else
        
        if goodNpc(i).Distance2 > goodNpcRange4 and goodNpc(i).Distance < goodNpcRange
            `return to scout mode
            goodNpc(i).goodNpcState = 1
        endif
    endif
    
    rem without this it wouldn't update the positions or rotations
    position object goodNpc(i).ObjNum,goodNpc(i).X,60+BT GetGroundHeight(g_Terrain_Main.dwTerrainID,goodNpc(i).X,goodNpc(i).Z),goodNpc(i).Z
next i


`DEBUG
remstart
ink rgb(255,255,255)
for c=1 to array count(path_Paths(0))
    text 10,c*10+200,str$(path_Paths(c).X)+","+str$(path_Paths(c).Y)
next c

ink rgb(255,0,0)
for c=0 to array count(goodNpc(0))
    text 100,goodNpc(c).Path_Start*10+200,str$(c)
    text 100,goodNpc(c).Path_End*10+200,"/"+str$(c)
    dk convert 3d to 2d 0,object position x(goodNpc(c).ObjNum),0,object position z(goodNpc(c).ObjNum)
    
    for d=goodNpc(c).Path_Start to goodNpc(c).Path_End
        tempx#=dk get pick vector x()
        tempy#=dk get pick vector y()
        if array index valid(path_Paths(d))
            dk convert 3d to 2d 0,path_Paths(d).X,0,path_Paths(d).Y
            if tempx#>0 and tempy#>0 and tempx#<screen width() and tempy#<screen height()
                line tempx#,tempy#,dk get pick vector x(),dk get pick vector y()
            endif
        endif
    next d
next c

ink rgb(255,255,255)
text 600,10,str$(PLR_footpos.x)+","+str$(PLR_footpos.z)

for c=1 to array count(path_Lines(0))
    dk convert 3d to 2d 0,path_Verts(path_Lines(c).V1).X,0,path_Verts(path_Lines(c).V1).Y
    tempx#=dk get pick vector x()
    tempy#=dk get pick vector y()
    dk convert 3d to 2d 0,path_Verts(path_Lines(c).V2).X,0,path_Verts(path_Lines(c).V2).Y
    if tempx#>0 and tempy#>0 and tempx#<screen width() and tempy#<screen height()
        line tempx#,tempy#,dk get pick vector x(),dk get pick vector y()
    endif
next c
remend
`/DEBUG


rem note I didn't add no ai states in the bad npc, so the code is just there
for i = 0 to badNpcs
rem this moves the bad npc randomly
 BadNpc_Npc_Move_Random(i)
rem this makes sure the bad npc stays inbounds
 BadNpc_Npc_Stay_Inbounds(i)
  `BadNpc_Point_At_GoodNpc(i)
rem this is are bad npc distance formulas
 BadNpc_Distance_Formulas(i)
rem this tells us if a bad npc is dead respawn it
 BadNpc_Respawn(i)
rem without this it wouldn't update the positions or rotations
  yrotate object badNpc(i).ObjNum,badNpc(i).Angle
  position object badNpc(i).ObjNum,badNpc(i).X,60+BT GetGroundHeight(g_Terrain_Main.dwTerrainID,badNpc(i).X,badNpc(i).Z),badNpc(i).Z
next i


`Run pathing queue
if array count(PathingQueue(0))>0
    goodNpc(PathingQueue(1)).path_start=array count(path_Paths(0))+1
    Path(goodNpc(PathingQueue(1)).X,goodNpc(PathingQueue(1)).Y,goodNpc(PathingQueue(1)).Target.X,goodNpc(PathingQueue(1)).Target.Y)
    goodNpc(PathingQueue(1)).path_end=array count(path_Paths(0))
    array delete element PathingQueue(0),1
endif


endfunction



function BadNpc_Respawn(i as integer)
rem if health  = 0 then respawn the bad npc
   if badNpc(i).Health = 0
rem give the bad npc health so there alive again
      badNpc(i).Health = 1
rem position the bad npc at a random location
      badNpc(i).X = -rnd(30)+rnd(30)
      badNpc(i).Z = -rnd(30)+rnd(30)
   endif
endfunction

function BadNpc_Npc_Move_Random(i as integer)
rem this tells the bad npcs which way to move
rem if direction = 1 move forward
if badNpc(i).Direction = 1 then badNpc(i).Z = badNpc(i).Z + badNpc(i).Speed * elapsedtime
rem if direction = 2 move backwards
if badNpc(i).Direction = 2 then badNpc(i).Z = badNpc(i).Z - badNpc(i).Speed * elapsedtime
rem if direction = 3 move right
if badNpc(i).Direction = 3 then badNpc(i).X = badNpc(i).X + badNpc(i).Speed * elapsedtime
rem if direction = 4 move left
if badNpc(i).Direction = 4 then badNpc(i).X = badNpc(i).X - badNpc(i).Speed * elapsedtime
rem we make a timer to say each 2000 milliseconds change the bad npcs direction
   if timer()-badNpc(i).RandomTimer > 2000
rem pick a random direction
      badNpc(i).Direction = rnd(3)+1
rem update the timer so it works
      badNpc(i).RandomTimer = timer()
   endif
endfunction

function BadNpc_Distance_Formulas(i as integer)
rem this is are badnpcs distance formulas
   for j = 0 to goodNpcs-i
rem this gets the distance from the bad npcs to the good npcs
      badNpc(i).Distance = sqrt((badNpc(i).X-goodNpc(j).X)^2+(badNpc(i).Z-goodNpc(j).Z)^2)
rem this points the bad npcs at the good npcs if its less then badNpcRange
      if badNpc(i).Distance <  badNpcRange
rem point at the good npcs
         BadNpc_Point_At_GoodNpc(i)
      endif
   next j
endfunction


function BadNpc_Npc_Stay_Inbounds(i as integer)

rem this is are tempary stay in bounds area
rem if bad npc goes farther than 30
rem  then change the bad npc direction, so the bad npc goes left
if badNpc(i).X > 2000
rem make the bad npc go left
    badNpc(i).Direction = 4
endif
rem if bad npc goes less than -30
rem  then change the bad npc direction, so the bad npc goes right
if badNpc(i).X < 0
rem make the bad npc go right
    badNpc(i).Direction = 3
endif
rem if bad npc goes farther than 30
rem  then change the bad npc direction, so the bad npc goes backwards
if badNpc(i).Z > 2000
rem makes the bad npc to backwards
    badNpc(i).Direction = 2
endif
rem if bad npc goes less than -30
rem  then change the bad npc direction, so the bad npc goes forward
if badNpc(i).Z < 0
rem makes the bad npc to forward
    badNpc(i).Direction = 1
endif

endfunction

function BadNpc_Point_At_GoodNpc(i as integer)
rem this is how we point the goodNpc at the player
rem this is 10X faster then point object, so this gives us better performance
rem were getting the point between the badNpc, and goodNpc
   for j = 0 to  goodNpcs-i
rem were getting the point betwween the badNpc x, and goodNpc x
       badNpc(i).DistanceX = (badNpc(i).X-goodNpc(j).X)
rem were getting the point betwween the badNpc z, and goodNpc z
      badNpc(i).DistanceZ = (badNpc(i).Z-goodNpc(j).Z)
rem we then put are formula's in the atanfull to get the angle between to objects
       badNpc(i).Angle = atanfull(badNpc(i).DistanceX ,badNpc(i).DistanceZ)
    next j
endfunction


function Debugg_Program()
rem all debugg goes here
rem shows the ai modes
   for  i= 0 to goodNpcs
      if goodNpc(i).goodNpcState = 0
         text 20,20*i,"goodNpc "+str$(i)+" No threat Mode: "`+str$(goodNpc(i).goodNpcState)
      endif

      if goodNpc(i).goodNpcState = 1
         text 20,20*i,"goodNpc "+str$(i)+" Scout Mode: "`+str$(goodNpc(i).goodNpcState)
      endif

      if goodNpc(i).goodNpcState = 2
         text 20,20*i,"goodNpc "+str$(i)+ " Attack Mode: "`+str$(goodNpc(i).goodNpcState)
      endif
   next i

endfunction


////////// PATHING /////////////
function Path(StartX,StartY,EndX,EndY)

`Straight line path exemption
`If there is a direct path, don't bother pathfinding!
if Raycast(StartX,StartY,EndX,EndY,0,0)=0
    cls rgb(255,255,255)
    array insert at bottom path_Paths(0)
    path_Paths(array count(path_Paths(0))).X=EndX
    path_Paths(array count(path_Paths(0))).Y=EndY
    exitfunction
endif

UNDIM TempNodes(0)
local DIM TempNodes(array count(path_Verts(0))) as path_AStarNode

`Set any nodes visible from start location to "Open"
for c=1 to array count(path_Verts(0))
    if Raycast(StartX,StartY,path_Verts(c).X,path_Verts(c).Y,0,0)=0
        TempNodes(c).Open=1
        TempNodes(c).Parent=0
        TempNodes(c).G=SQRT((StartX-path_Verts(c).X)^2+(StartY-path_Verts(c).y)^2)
        TempNodes(c).H=abs(StartX-path_Verts(c).X)+abs(StartY-path_Verts(c).y)
        TempNodes(c).F=TempNodes(c).G+TempNodes(c).H
    endif
next c

`While we can't see the destination...
while Raycast(path_Verts(winner).X,path_Verts(winner).Y,EndX,EndY,0,0)=1 or winner=0

    `Find the open node with the lowest score
    score=99999
    winner=0
    for c=1 to array count(TempNodes(0))
        if TempNodes(c).Open=1 and TempNodes(c).Closed=0
            if TempNodes(c).F<score
                winner=c
                score=TempNodes(c).F
            endif
        endif
    next c
    
    `If we didn't find any open nodes, we're stuck.  Quit and blacklist.
    if winner=0 then exitfunction
    
    TempNodes(winner).Closed=1
    
    `Open any nodes visible from the one we found above
    for c=1 to array count(path_Connections(0))
        temp=0
        if path_Connections(c).V1=winner then temp=path_Connections(c).V2
        if path_Connections(c).V2=winner then temp=path_Connections(c).V1
        
        `[Make sure this doesn't cross through the vertex]
        
        if temp>0
            if TempNodes(temp).Open=0
                TempNodes(temp).Open=1
                TempNodes(temp).Parent=winner
                TempNodes(temp).G=TempNodes(winner).G+path_Connections(c).Distance
                TempNodes(temp).H=abs(path_Verts(winner).X-path_Verts(temp).X)+abs(path_Verts(winner).Y-path_Verts(temp).y)
                TempNodes(temp).F=TempNodes(temp).G+TempNodes(temp).H
                else
                if TempNodes(temp).G>TempNodes(winner).G+path_Connections(c).Distance
                    TempNodes(temp).Parent=winner
                    TempNodes(temp).G=TempNodes(winner).G+path_Connections(c).Distance
                    TempNodes(temp).F=TempNodes(temp).G+TempNodes(temp).H
                endif
            endif                    
        endif
    next c

endwhile

`Backtrack to find path
if winner>0
    repeat
        array insert at top path_Paths(0)
        path_Paths(1).X=path_Verts(winner).X
        path_Paths(1).Y=path_Verts(winner).Y
        winner=TempNodes(winner).Parent
    until winner=0
endif

array insert at bottom path_Paths(0)
path_Paths(array count(path_Paths(0))).X=EndX
path_Paths(array count(path_Paths(0))).Y=EndY

endfunction




function Raycast(X1 as integer,Y1 as integer,X2 as integer,Y2 as integer,NL1,NL2)
for c=1 to array count(path_Lines(0))
    if c<>NL1 and c<>NL2
        if FastLineIntersection(X1,Y1,X2,Y2,path_Verts(path_Lines(c).V1).X,path_Verts(path_Lines(c).V1).Y,path_Verts(path_Lines(c).V2).X,path_Verts(path_Lines(c).V2).Y) then exitfunction 1
    endif
next c
endfunction 0


`by IanM
function FastLineIntersection(Ax as float,Ay as float,Bx as float,By as float,Cx as float,Cy as float,Dx as float,Dy as float)
local r as float : local s as float : local d as float : local n as float
n = ((Ay - Cy) * (Dx - Cx)) - ((Ax - Cx) * (Dy - Cy))
d = ((Bx - Ax) * (Dy - Cy)) - ((By - Ay) * (Dx - Cx))
if d = 0 then exitfunction 0
r = n / d
s = ( ((Ay-Cy)*(Bx-Ax))-((Ax-Cx)*(By-Ay)) ) / d
if r <= 0 then exitfunction 0
if r >= 1 then exitfunction 0
if s <= 0 then exitfunction 0
if s >= 1 then exitfunction 0
endfunction 1


function near(a#,b#)
temp#=30.0
if a#+temp#>b# and a#-temp#<b# or b#+temp#>a# and b#-temp#<a# then exitfunction 1
endfunction 0


/////////////////////////////////////////////////////////
// TERMINATE                                           //
/////////////////////////////////////////////////////////


function terminateAI()
UI_WriteLog(UI_Green,"=== Terminating AI module")
for i=0 to array count(goodNpc(0))
    freeResource(goodNpc(i).ObjNum,res_Object)
next i
UNDIM goodNpc(0)

for i=0 to array count(badNpc(0))
    freeResource(badNpc(i).ObjNum,res_Object)
next i
UNDIM badNpc(0)
UI_WriteLog(UI_Green,"=== AI module terminated")
endfunction