remstart
/////////////////////////////////////////////////////
//
// OpenFPS INPUT Module
//
// Created by thenerd
//
/////////////////////////////////////////////////////

----- Changelog:

(11/29/10) - thenerd 		- Created.

----- To-Do:
-None-

----- Purpose:
Handles user input for the game engine.

----- Dependancies and Conflicts:
-None-

----- Other Notes:
* The functions and resoures in this module use the prefix IO_

The SetBind and GetBind functions can be used to set the bindings
for user controls. They are automatically executed on load from
the config file. Standard binds for server communication are:

Server binds:
+forward
+backward
+left
+right
+turnleft
+turnright
+jump
+crouch
+crouchtoggle
+prone
+fire1
+fire2
+reload

Client binds:
-zoom
-menu
-talk
-vtalk
-kill
-respawn

All binds with + are sent to the server. All binds with - are client-side only.

ANOTHER NOTE:
Most of the code in this module is temporary. 
Eventually, there will be custom binds supported,
along with binds that execute console commands and similar.

There is also some simple code for camera handling in this module.

/////////////////////////////////////////////////////
remend

/////////////////////////////////////////////////////////
// TYPES                                               //
/////////////////////////////////////////////////////////

type Bind
	key as integer
	in as boolean
	io_toggle as integer
endtype

type Camera
	x as float
	y as float
	z as float
	rx as float
	ry as float
	rz as float
endtype

/////////////////////////////////////////////////////////
// INIT                                                //
/////////////////////////////////////////////////////////

function IO_Init():
	global IO_BIND_forward as Bind
	global IO_BIND_backward as Bind
	global IO_BIND_left as Bind
	global IO_BIND_right as Bind
	global IO_BIND_turnleft as Bind
	global IO_BIND_turnright as Bind
	global IO_BIND_jump as Bind
	global IO_BIND_crouch as Bind
	global IO_BIND_crouchtoggle as Bind
	global IO_BIND_prone as Bind
	global IO_BIND_fire1 as Bind
	global IO_BIND_fire2 as Bind
	global IO_BIND_reload as Bind
	IO_BIND_forward.key = 17
	IO_BIND_backward.key = 31
	IO_BIND_left.key = 30
	IO_BIND_right.key = 32
	IO_BIND_turnleft.key = 75
	IO_BIND_turnright.key = 77
	IO_BIND_jump.key = 57
	IO_BIND_crouch.key = 29
	IO_BIND_crouchtoggle.key = -1
	IO_BIND_prone.key = 46
	IO_BIND_fire1.key = -2
	IO_BIND_fire2.key = -3
	IO_BIND_reload.key = 19
endfunction

/////////////////////////////////////////////////////////
// MAIN                                                //
/////////////////////////////////////////////////////////

function IO_SetBind():
endfunction

function IO_GetBind(_bind$):
	//returns if the bind is pressed
	return_io=0
	select _bind$
	case "+forward"
		return_io=keystate(IO_BIND_forward.key)
	endcase
	case "+backward"
		return_io=keystate(IO_BIND_backward.key)
	endcase
	case "+left"
		return_io=keystate(IO_BIND_left.key)
	endcase
	case "+right"
		return_io=keystate(IO_BIND_right.key)
	endcase
	case "+turnleft"
		return_io=keystate(IO_BIND_turnleft.key)
	endcase
	case "+turnright"
		return_io=keystate(IO_BIND_turnright.key)
	endcase
	case "+jump"
		return_io=keystate(IO_BIND_jump.key)
	endcase
	case "+crouch"
		return_io=keystate(IO_BIND_crouch.key)
	endcase
	case "+crouchtoggle"
		return_io=keystate(IO_BIND_crouchtoggle.key)
	endcase
	case "+prone"
		return_io=keystate(IO_BIND_prone.key)
	endcase
	case "+fire1"
		return_io=keystate(IO_BIND_fire1.key)
	endcase
	case "+fire2"
		return_io=keystate(IO_BIND_fire2.key)
	endcase
	case "+reload"
		return_io=keystate(IO_BIND_reload.key)
	endcase
	endselect
endfunction return_io

function IO_GetTap(_bind$):
	//returns if the bind is tapped
	//I'll code this eventually
endfunction

/////////////////////////////////////////////////////////
// MOUSELOOK                                           //
/////////////////////////////////////////////////////////

function CAM_Init():
	//spectator camera function
	global CAM_Spectate as Camera
	
	global wrapangle as float = 0.0
	global camRotX as float
	global camRotY as float
	global camRotVelX as float
	global camRotVelY as float
	global camSmoothness as float = 5.0
	global camSpeed as float = 1.0
endfunction

function CAM_Update():
	//spectator camera function	cam
	
	//rotation
	camRotVelX = TCurveValue(mousemovey()*camSpeed,camRotVelX,camSmoothness)
	camRotVelY = TCurveValue(mousemovex()*camSpeed,camRotVelY,camSmoothness)
	camRotX = wrapvalue(camRotX+camRotVelX)
	camRotY = wrapvalue(camRotY+camRotVelY)
	CAM_Spectate.rx=camRotX
	CAM_Spectate.ry=camRotY
	CAM_Spectate.rz=0.0
	
	rotate camera CAM_Spectate.rx,CAM_Spectate.ry,CAM_Spectate.rz
	`position camera CAM_Spectate.x,CAM_Spectate.y,CAM_Spectate.z
	`IO_GetBind("+forward")
	if KEYSTATE(17) then move camera 1*SyS_TimeFactor
	if KEYSTATE(31) then move camera -1*SyS_TimeFactor
	if KEYSTATE(30) then move camera left 1*SyS_TimeFactor
	if KEYSTATE(32) then move camera right 1*SyS_TimeFactor
	if KEYSTATE(75) then dec CAM_Spectate.ry,1*SyS_TimeFactor
	if KEYSTATE(77) then inc CAM_Spectate.ry,1*SyS_TimeFactor
	if KEYSTATE(57) then move camera up 1*SyS_TimeFactor
	
	CAM_Spectate.x=camera position x()
	CAM_Spectate.y=camera position y()
	CAM_Spectate.z=camera position z()
	rotate camera CAM_Spectate.rx,CAM_Spectate.ry,CAM_Spectate.rz
	position camera CAM_Spectate.x,CAM_Spectate.y,CAM_Spectate.z
endfunction

function CAM_Terminate():
	//spectator camera function
endfunction

function TCurveValue(dest as float, current as float, speed as float)
	local diff as float
	local value as float
	`Put extreme limit on to stop variables jumping to infinity
	if SyS_TimeFactor > 1000 then exitfunction current
	`Find difference between destination and current position
	diff = dest - current
	`Caluclate new value
	value = current + (diff * ((speed^SyS_TimeFactor-(speed-1)^SyS_TimeFactor)/(speed^SyS_TimeFactor)))
endfunction value

function TCurveAngle(dest as float, current as float, speed as float)
	local diff as float
	local value as float
	local tempCurrent as float
	`Put extreme limit on to stop variables jumping to infinity
	if SyS_TimeFactor > 1000 then exitfunction current
	`Wrap current around so that it is as if destination is 0
	tempCurrent = wrapvalue(current - dest)
	`See if it's in the first half (<180) or the second half (>180) and assign movement amounts
	if tempCurrent <= 180.0
		diff = -tempCurrent
	else
		diff = 360-tempCurrent
	endif
	`Caluclate new value
	value = wrapvalue(current + (diff * ((speed^SyS_TimeFactor-(speed-1)^SyS_TimeFactor)/(speed^SyS_TimeFactor))))
endfunction value


/////////////////////////////////////////////////////////
// TERMINATE                                           //
/////////////////////////////////////////////////////////

function IO_Terminate():
endfunction

// end of code