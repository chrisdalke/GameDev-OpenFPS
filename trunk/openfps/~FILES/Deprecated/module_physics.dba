remstart
/////////////////////////////////////////////////////
//
// OpenFPS PHYSICS Module
//
// Created by thenerd
// Maintained by thenerd
//
/////////////////////////////////////////////////////

----- Changelog:
(9/20/10) - thenerd - Created.

----- To-Do:
*Blank*

----- Purpose:
Handles all physics-related tasks such as:
-Movement
-Shooting
-Vehicles
-Dynamic Bodies
-Ragdolls

----- Dependancies and Conflicts (IMPORTANT STUFF):
This module uses version 1.53 of the NDB Newton wrapper.
the latest version can be found here:
http://forum.thegamecreators.com/?m=forum_view&t=154086&b=5

----- Other Notes:
All the functions and variables in this module
use the prefix "PHY_" in their names for clarity.

----- Vehicles:
Vehicles are a WIP, so they are not guaranteed to work, and
could crash at times.
Right now, only one vehicle (the jeep) works, this is just a 
test. Later vehicles will be added via scripting and external
files.
The vehicle system uses an array, so the maximum number of 
vehicles is 32 at one time. Any more than this will cause the
game to crash.

----- Object setup options:
MaterialTypes:
* Default (0) - No Settings. (DEFAULT)
PLANNED:
* Wood     (1) - Wood Material. 
* Metal    (2) - Metal Material.
* Concrete (3) - Stone Material.

remend

/////////////////////////////////////////////////////
// 	GLOBALS
/////////////////////////////////////////////////////

`MaterialTypes:
global PHY_MType_DEFAULT  as integer
`NDB Variables:
global PHY_WorldSize# as float
global PHY_time#      as float
global PHY_Debug      as integer
global PHY_CLICK	  as integer
`TYPES:
type PHY_VehicleBase
   ObjectID as integer
   TextureID as integer
   Vis_Camera as integer
   Vis_Height as float
   Vis_Distance as float
   Vis_MouseLook as integer
   Vis_InitAngle as float
   Vis_Soundset as integer
endtype
type PHY_Controller
	Initialized as integer
	Camera as integer
	Speed as float
	JumpSpeed as float
	Height as float
	Mass as float
	Col as dword
	Body as dword
	UpVector as dword
	Mat as dword
	X_Angle as float
	Y_Angle as float
endtype
/////////////////////////////////////////////////////
// 	FUNCTIONS
/////////////////////////////////////////////////////

function PHY_init(world_size#,Debunk):
	`Start Newton
	NDB_NewtonCreate
	
	NDB_SetVector 0.0,-800.0,0.0
	NDB_SetStandardGravity
	
	`Set Debug
	PHY_Debug=Debunk
	
	`Set world limits
	PHY_WorldSize#=world_size#
	NDB_SetVector 1, 0-PHY_WorldSize#,0-PHY_WorldSize#,0-PHY_WorldSize#
	NDB_SetVector 2, PHY_WorldSize#,PHY_WorldSize#,PHY_WorldSize#
	NDB_NewtonSetWorldSize
	
	`Assign Material Types
	PHY_MType_DEFAULT=0
	
	`Create character.
	PHY_AddCharacter()
	
	`Reset timer
	PHY_time# = NDB_GetElapsedTimeInSec()
endfunction

function PHY_AddTerrain(TerrainID,Collision):
	`Add BlitzTerrain object.	
	`Blank for now (until multiple terrains are implemented)
	`module_terrain automatically adds the terrain chunks in.
endfunction

function PHY_AddStaticObject(ObjectID,MaterialType):
	`Add static object.
	col = NDB_NewtonCreateTreeCollision(ObjectID,1)
	body = NDB_NewtonCreateBody( col )
	NDB_BuildMatrix object angle x(ObjectID),object angle y(ObjectID),object angle z(ObjectID),object position x(ObjectID),object position y(ObjectID),object position z(ObjectID)
	NDB_NewtonBodySetMatrix body
	NDB_BodySetDBProData body,1
	NDB_NewtonBodySetDestructorCallback body
endfunction

function PHY_AddDynamicObject(ObjectID,MaterialType,Link):
	`Add dynamic object.
	Col = NDB_NewtonCreateBox(object size x(ObjectID),object size y(ObjectID),object size z(ObjectID))
	Obj = NDB_NewtonCreateBody(Col)
	NDB_NewtonBodySetMassMatrix Obj,10.0,1.0,1.0,1.0
	NDB_BodySetDBProData Obj,1
	if Link>0 then NDB_NewtonBodySetDestructorCallback Obj
endfunction

function PHY_AddVehicle():
	`Add drivable vehicle :D
endfunction

function PHY_AddCharacter():
	`Add character controller.
	Global PHY_Char as PHY_Controller
	PHY_Char.Initialized = 1
	PHY_Char.Camera      = 0
	PHY_Char.Speed       = 200
	PHY_Char.JumpSpeed   = 500
	PHY_Char.Height      = 100
	PHY_Char.Mass        = 10.0
	PHY_Char.Col         = NDB_NewtonCreateSphere(PHY_Char.Height/2.0,PHY_Char.Height,PHY_Char.Height/2.0)
	PHY_Char.Body        = NDB_NewtonCreateBody(PHY_Char.Col)

	NDB_BuildMatrix 0.0,0.0,0.0,100,500,100
	NDB_NewtonBodySetMatrix PHY_Char.Body
	
	NDB_SetVector 6.0, 8.0, 6.0
	NDB_CalculateMIBoxSolid PHY_Char.Mass
	NDB_NewtonBodySetMassMatrix PHY_Char.Body,PHY_Char.Mass
	
	NDB_NewtonBodySetAutoFreeze PHY_Char.Body, 0
	NDB_BodySetGravity PHY_Char.Body,1
	NDB_SetVector 0.0, 1.0, 0.0
	PHY_Char.UpVector = NDB_NewtonConstraintCreateUpVector(PHY_Char.Body)

	Default=NDB_NewtonMaterialGetDefaultGroupID()
	PHY_Char.Mat=NDB_NewtonMaterialCreateGroupID()
	NDB_NewtonMaterialSetDefaultFriction Default,PHY_Char.Mat,0.01,0.01
	NDB_NewtonMaterialSetDefaultElasticity Default,PHY_Char.Mat,0.01
	NDB_NewtonBodySetMaterialGroupID PHY_Char.Body,PHY_Char.Mat
endfunction

function PHY_UpdateCharacter():
	`Update the character.
	inc PHY_Char.X_Angle,SyS_MouseMoveY*0.25
	inc PHY_Char.Y_Angle,SyS_MouseMoveX*0.25
	
	`put a limit on how much the player can loop up/down.
	if PHY_Char.X_Angle>80.0 then PHY_Char.X_Angle=80.0
	if PHY_Char.X_Angle<-80.0 then PHY_Char.X_Angle=-80.0

	`Position camera
	rotate camera PHY_Char.X_Angle,PHY_Char.Y_Angle,0.0
	NDB_BodyGetPosition PHY_Char.Body
	position camera NDB_GetVector_X(), NDB_GetVector_Y(), NDB_GetVector_Z()

	`Detect keys
	MoveX# = 0.0
	MoveZ# = 0.0
	Move=0
	if keystate(17) or keystate(31)
		dx# = sin(PHY_Char.Y_Angle)
		dz# = cos(PHY_Char.Y_Angle)
		inc MoveX#, dx# * (keystate(17)-keystate(31))
		inc MoveZ#, dz# * (keystate(17)-keystate(31))
		Move=1
	endif
	if keystate(30) or keystate(32)
		dx# = sin(PHY_Char.Y_Angle+90.0)
		dz# = cos(PHY_Char.Y_Angle+90.0)
		inc MoveX#, dx# * (keystate(32)-keystate(30))
		inc MoveZ#, dz# * (keystate(32)-keystate(30))
		Move=1
	endif
	length# = sqrt( (MoveX#^2)+(MoveZ#^2) )
	MoveX# = MoveX# / length#
	MoveZ# = MoveZ# / length#
	
	`Calculate vector
	NDB_NewtonBodyGetVelocity PHY_Char.Body
	CurrentVel_X# = NDB_GetVector_X()
	CurrentVel_Y# = NDB_GetVector_Y()
	CurrentVel_Z# = NDB_GetVector_Z()
	
	
	`Set vector to PHY_Char.Body
	GoalVel_X# = MoveX# * (PHY_Char.Speed * ((shiftkey()+1)*2) )
	GoalVel_Z# = MoveZ# * (PHY_Char.Speed * ((shiftkey()+1)*2) )
	VecX# = ((GoalVel_X# + CurrentVel_X# ) / PHY_time#)
	VecZ# = ((GoalVel_Z# + CurrentVel_Z# ) / PHY_time#)
	if VecX# > 200.0 then VecX# = 200.0
	if VecX# < -200.0 then VecX# = -200.0
	if VecZ# > 200.0 then VecZ# = 200.0
	if VecZ# < -200.0 then VecZ# = -200.0
		
	`Set vector to PHY_Char.Body
	if Move>0:
		NDB_BodyGetPosition PHY_Char.Body
		NDB_SetVector 2, VecX#, CurrentVel_Y#, VecZ#
		NDB_BodySetForceGlobal PHY_Char.Body
	endif
	
	`jumping
	AccelY# = 0.0
	if spacekey() and SPACEPRESSED = 0
		SPACEPRESSED = 1
		NDB_BodyGetPosition PHY_Char.Body
		px# = NDB_GetVector_X() : py# = NDB_GetVector_Y() : pz# = NDB_GetVector_Z()
		NDB_SetVector 1, px#, py#, pz#
		NDB_SetVector 2, px#, py# - 6.05, pz#
		dist# = NDB_NewtonWorldRayCast()
		if dist# < 1.0
			AccelY# = ((PHY_Char.JumpSpeed - CurrentVel_Y#) / PHY_time#)
			NDB_BodyGetPosition PHY_Char.Body
			NDB_SetVector 2, 0.0, AccelY#, 0.0
			NDB_BodyAddForceGlobal PHY_Char.Body
		endif
	endif
	if spacekey() = 0 then SPACEPRESSED = 0
	
endfunction

function PHY_update():
	`Debug
	if PHY_Debug>0:
		PHY_DebugTest()
		set cursor 0,0
		print "Screen FPS:",screen fps()
	endif
	
	`Update Character
	PHY_UpdateCharacter()

	`Update physics using elapsed time (TBM!)
	PHY_time# = NDB_GetElapsedTimeInSec()
	NDB_NewtonUpdate PHY_time#
endfunction

function PHY_DebugTest():

	`Tests the physics system.
	`NDB_DebugDrawNewtonLines
	if controlkey() then NDB_DebugDrawNewtonLines
	
	`Throw spheres
	if mouseclick()=1 and PHY_CLICK=0
		PHY_CLICK=1
		`Make Sphere
		PHY_MakeDebugSphere(camera position x(),camera position y(),camera position z(),50.0,20.0)
	endif
	if mouseclick()=0 then PHY_CLICK=0
	
endfunction

function PHY_MakeDebugSphere(x#,y#,z#,s#,mass#)
	Col = NDB_NewtonCreateSphere( s# )
	Body = NDB_NewtonCreateBody(Col)
	`Set initial position and rotation
	NDB_BuildMatrix 0.0, 0.0, 0.0,x#,y#,z#
	NDB_NewtonBodySetMatrix Body
	NDB_CalculateMISphereSolid mass#, s#
	NDB_NewtonBodySetMassMatrix Body, mass#
	NDB_NewtonReleaseCollision Col

	Object = grabResource(res_Object)
	make object sphere Object,s#
	color object Object,GetColor()
	set object ambience Object,50
	position object Object,x#,y#,z#
	
	NDB_BodySetDBProData Body,Object
	NDB_NewtonBodySetDestructorCallback Body
	NDB_BodySetGravity Body,1
		
	`Calculate Vector
	x1#=camera position x():y1#=camera position y():z1#=camera position z():move camera 1.0
	x2#=camera position x():y2#=camera position y():z2#=camera position z():move camera -1.0
	unit_x#=x2#-x1#:unit_y#=y2#-y1#:unit_z#=z2#-z1#:vel#=1000.0
	vel_x#=unit_x#*vel#:vel_y#=unit_y#*vel#:vel_z#=unit_z#*vel#
	`Set Vector
	NDB_SetVector vel_x#, vel_y#, vel_z#
	NDB_NewtonBodySetVelocity Body
endfunction

function PHY_end(EndAll):
	`Clean up and end...WARNING! THIS DELETES DB OBJECTS AS WELL!
	if EndAll>0:
		NDB_NewtonDestroy
	endif
endfunction

/////////////////////////////////////////////////////
// 	MISC
/////////////////////////////////////////////////////

function GetColor()
	repeat
		r = rnd(1)*255
		g = rnd(1)*255
		b = rnd(1)*255
	until r<>0 or g<>0 or b<> 0
	color =  rgb(r,g,b)
endfunction color