rem make the good npcs for OpenFPS By darkvee
rem delcare variables
global timerBasedTimer as integer = timer()

rem these are my ranges for distance formulas
rem were going to use
global goodNpcRange as float
goodNpcRange = 15.0

global goodNpcRange2 as float
goodNpcRange2 = 10.0

global goodNpcRange3  as float
goodNpcRange3 = 10.0

global goodNpcRange4 as float
goodNpcRange4 = 40.0

global badNpcRange as float
badNpcRange = 40.0

rem just a bullet timer that tells how long to respawn a new bullet
global goodNpcBulletTime  as integer = timer()

rem are player type
   type PlayerType
      ObjNum as integer
      X as float
      Y as float
      Z as float
      AngleX as float
      AngleY as float
      AngleZ as float
      Distance as Float
   endtype
rem this is are name of are player type were going to use
   global player as  PlayerType

rem are team mate npc type
   type GoodNpcType
      ObjNum as integer
      X as float
      Y as float
      Z as float
      Speed as float
      Distance as Float
      Distance2 as float
      DistanceX as float
      DistanceZ as float
      Distance2X as float
      Distance2Z as float
      Angle as float
      Rotate as integer
      Direction as integer
      GoodNpcState as integer
      DirectionTimer as integer = timer()
      RotationTimer as integer = timer()
   endtype
   global goodNpcs as integer
   goodNpcs = 7
rem this is are name of are team mate npc type were going to use
   dim goodNpc(goodNpcs) as GoodNpcType
rem bad npc team
  type BadNpcType
      ObjNum as integer
      X as float
      Y as float
      Z as float
      Speed as float
      Distance as Float
      Angle as float
      Rotate as integer
      Direction as integer
      DistanceX as float
      DistanceZ as float
      RandomTimer as integer = timer()
      DirectionTimer as integer = timer()
      Health as integer
   endtype
rem tells how many bad npcs were making
   global badNpcs as integer
   badNpcs = 7
rem we use badNpcs to give a value how many badNpcs are in the team
   dim badNpc(badNpcs) as BadNpcType
rem this is going to be are goodNpc bullets
 type GoodNpcBulletType
      ObjNum as integer
      X as float
      Y as float
      Z as float
      Speed as float
      Distance as Float
      Distance2 as float
      Angle as float
      Rotate as float
      Alive as integer
      Direction as integer
      DistanceX as float
      DistanceZ as float
      DirectionTimer as integer = timer()
      Range as integer
   endtype
rem this is how many goodNpc bullets we have
   global goodNpcBullets as integer
rem this is how many goodNpc bullets we have
   goodNpcBullets = 7
rem we plug this value in are array so it tells us how many bullets were going to have
   dim goodNpcBullet(goodNpcBullets) as GoodNpcBulletType
rem load ai demo
   Load_Demo()
rem run ai demo
   Run_Demo()

function Load_Players_And_Good_Npc()
rem load all are stuff
rem load player
   Make_Player()
rem load are GoodNpc team mates
   Make_Good_Npc()
rem load are BadNpc team
   Make_Bad_Npc()
rem load are bullets for are goodNpc team
   Make_Good_Npc_Bullet()
endfunction

function Make_Player()

rem giving are player some variable values
rem this is are player number were going to use
   player.ObjNum = 1
rem this is are player position variable values
   player.X = 0
   player.Y = 0
   player.Z = 50
rem now we make the player
   make object cube  player.ObjNum,1
rem we a give color of yellow to the player
   color object player.ObjNum,rgb(255,255,0)
rem we put are player variable values in to update the position of the player
rem without this it wouldn't update the positions or rotations
   position object player.ObjNum,player.X,player.Y,player.Z
endfunction

function Make_Good_Npc()

rem were going to have 8 to 12 good npc team members helping us
rem this is how we make are good npc
rem were giving are good npc some variable values
for i = 0 to goodNpcs
rem this is are good npc number were going to use
rem notice i+2 this means it goes from i = 2 to 9, because player.objNum = 1 we can't have 1
   goodNpc(i).ObjNum = i+2
rem this is are good npc position variable values
rem this spreads them out for now so they don't touch each other at the start
   goodNpc(i).X = -7+i*2
   goodNpc(i).Y = 0
rem this moves them behind each other in a random fashion
   goodNpc(i).Z = 50+rnd(5)
rem this is are good npc speed how fast they will move first
   goodNpc(i).Speed = 0.2
rem now we make the good npc
   make object cube  goodNpc(i).ObjNum,1
rem color are team mates blue
   color object goodNpc(i).ObjNum,rgb(0,0,255)
rem we put are good npc variable values in to update the position of the good npc
rem without this it wouldn't update the positions or rotations
   position object  goodNpc(i).ObjNum,goodNpc(i).X,goodNpc(i).Y,goodNpc(i).Z
next i

endfunction


function Make_Bad_Npc()

rem were going to have 8 to 12 good npc team members helping us
rem this is how we make are good npc
rem were giving are good npc some variable values
for i = 0 to badNpcs
rem this is are good npc number were going to use
rem notice i+2 this means it goes from i = 2 to 9, because player.objNum = 1 we can't have 1
   badNpc(i).ObjNum = i+10
rem this is are good npc position variable values
rem this spreads them out for now so they don't touch each other at the start
   badNpc(i).X = -rnd(30)+rnd(30)
   badNpc(i).Y = 0
rem this moves them behind each other in a random fashion
   badNpc(i).Z = -rnd(30)+rnd(30)
rem this is are good npc speed how fast they will move first
   badNpc(i).Speed = 0.2

   badNpc(i).Health = 1
rem now we make the good npc
   make object cube  badNpc(i).ObjNum,1
   color object badNpc(i).ObjNum,rgb(255,0,0)
rem we put are good npc variable values in to update the position of the good npc
rem without this it wouldn't update the positions or rotations
   position object  badNpc(i).ObjNum,badNpc(i).X,badNpc(i).Y,badNpc(i).Z
next i

endfunction

function Make_Good_Npc_Bullet()
rem we make are bullets
   for  i = 0 to goodNpcBullets
rem we give goodNpcBullet(i).ObjNum = i+18,  because the last object number we used was i+ 10 we load in 7 bad guys, so that's i = 17
      goodNpcBullet(i).ObjNum = i +18
rem  just give the bullets a very long position off the screen
      goodNpcBullet(i).X = 9999
      goodNpcBullet(i).Z = 9999
rem give the bullets some speed
      goodNpcBullet(i).Speed = 3
rem make are cube to represent are bullet
      make object cube goodNpcBullet(i).ObjNum,0.2
rem without this it wouldn't update the positions or rotations
      position object  goodNpcBullet(i).ObjNum,goodNpcBullet(i).X,goodNpcBullet(i).Y,goodNpcBullet(i).Z
   next i
endfunction

function Load_Demo_Display()
rem this isn't important were only using this to show off the npc's this won't be in the game.
   autocam off
   hide mouse
   sync on
   set display mode 1024,768,screen depth()
   backdrop on
   color backdrop 0,rgb(100,100,100)
endfunction


Function Use_Demo_Camera()
rem this isn't important  were only using this to show off the npc's this won't be in the game.
   camX# = WrapValue(camera Angle X() + MouseMoveY())
   camY# = WrapValue(camera Angle Y() + MouseMoveX())
   camZ# = wrapvalue(camera Angle Z())

   rotate camera camX#,camY#,camZ#
   if mouseclick()=1 then move camera 0,1
   if mouseclick()=2 then move camera 0,-1

EndFunction

function Control_Player()

rem if the player presses W then move the player forward
   if keystate(17)=1 then player.Z = player.Z + 0.4
rem if the player presses S then move the player backwards
   if keystate(31)=1 then player.Z = player.Z - 0.4
rem if the player presses D then move the player right
   if keystate(32)=1 then player.X = player.X + 0.4
rem if the player presses A then move the player left
   if keystate(30)=1 then player.X = player.X - 0.4


endfunction

function Update_Player()
rem make sure we update the players position, and rotation
   rotate object player.ObjNum,player.AngleX,player.AngleY,player.AngleZ
   position object player.ObjNum,player.X,player.Y,player.Z
endfunction

function Update_All_Player_Settings()
rem this controls are play movements
    Control_Player()
rem this makes sure are player movements are getting updated
    Update_Player()
endfunction

function Load_Demo()
rem load are display
   Load_Demo_Display()
rem load are player and goodNpc
   Load_Players_And_Good_Npc()
endfunction

function Run_Demo()
position camera 0,100,0
point camera 0,0,65
rem this is are game up
do
rem this is how we make a timerBased Movement
rem if timer() minus timerBasedTimer this equals 0 then we say is it greater then 16
rem 1000/60 the 1000 is 1 second, and 60 is 60 fps. anways
rem 1000/60 equals 16.66666666666667  we just round this to 16.
rem this makes sure the game runs at this speed on everyones pc.
   if timer()-timerBasedTimer > 16
rem we put all are code we want to run here

      Use_Demo_Camera()
      Update_All_Player_Settings()
      Update_All_GoodNpc_Settings()
      Update_All_GoodNpcBullet_Settings()
      Update_All_BadNpc_Settings()

rem this updates are timerBasedTimer making sure its working.
      timerBasedTimer = timer()
   endif
rem we put are debugg function outside so we can see the real fps if not its 60 fps lol
   Debugg_Program()
rem this makes sure everything gets drawn
sync
rem this is the end of are game loop
loop
endfunction

function Update_All_GoodNpc_Settings()
rem this updates all of the goodNpc settings
   for i = 0 to goodNpcs
rem follow the player mode:
rem this is what makes the goodNpc move
rem this is how we make the goodNpc follow the player
      if goodNpc(i).goodNpcState = 0
         Move_GoodNpc(i)
         GoodNpc_Follow_The_Player(i)
      endif
rem scout mode:
rem scout the area for enemies
      if goodNpc(i).goodNpcState = 1
         GoodNpc_Do_Random_Movement(i)
      endif
rem attack mode:
rem if badNpc the enemy is in sight point at the enemy
rem and move around randomly while pointing at the enemy this is attack mode
      if goodNpc(i).goodNpcState = 2
         GoodNpc_Do_Random_Movement(i)
         GoodNpc_Point_At_BadNpc(i)
         GoodNpc_Fire_Bullet(i)
      endif

rem this is what makes the GoodNpc Think
      GoodNpc_Brain_Think(i)
rem this uses any of are GoodNpc distance formulas
      GoodNpc_Distance_Formulas(i)
rem this makes sure are goodNpcs stay inbounds from the player, and not get out of bounds
      GoodNpc_Stay_Inbounds(i)
rem without this it wouldn't update the positions or rotations
      position object goodNpc(i).ObjNum,goodNpc(i).X,goodNpc(i).Y,goodNpc(i).Z
   next i
endfunction

function Update_All_GoodNpcBullet_Settings()
rem this updates all the goodNpcbullet settings
   for i = 0 to goodNpcBullets
rem move the bullet
       GoodNpc_Move_Bullet(i)
rem get are distance formulas
       GoodNpc_Bullet_Distance_Formulas(i)
rem make sure are bullet stays inbounds
       GoodNpc_Bullet_Stay_Inbounds(i)
      `GoodNpcBullet_Point_At_BadNpc()
rem updates all the goodNpcBullet position , and rotation
      yrotate object goodNpcBullet(i).ObjNum,goodNpcBullet(i).Angle
      position object goodNpcBullet(i).ObjNum,goodNpcBullet(i).X,goodNpcBullet(i).Y,goodNpcBullet(i).Z
    next i
endfunction

function GoodNpc_Bullet_Distance_Formulas(i as integer)
rem we use are distance formulas here
   for j = 0 to badNpcs-i
rem make a distance formula
      goodNpcBullet(i).Distance = sqrt((goodNpcBullet(i).X-badNpc(j).X)^2+(goodNpcBullet(i).Z-badNpc(j).Z)^2)
rem if distance is less then 1 then a collision toke place, and
rem killed a red BadNpc team mate
      if goodNpcBullet(i).Distance < 1
rem we now set the bullet to not alive, so bullet is now dead
         goodNpcBullet(i).Alive = 0
rem if bullet is dead then position the bullets far off
         goodNpcBullet(i).X = - 9999
         goodNpcBullet(i).Z = - 9999
rem decrease Health by 1
         badNpc(j).Health = badNpc(j).Health - 1
rem if Health is less then  or equal to 0 then make sure Health doesn't go below 0
         if badNpc(j).Health <= 0 then badNpc(j).Health = 0
rem we now hide the object, because the bullet is dead
         hide object goodNpcBullet(i).ObjNum
      endif
rem without this it wouldn't update the positions or rotations
      position object badNpc(j).ObjNum,badNpc(j).X,badNpc(j).Y,badNpc(j).Z
   next j
endfunction

function GoodNpc_Brain_Think(i as integer)
rem this is how are GoodNpc thinks, and uses ai states
rem if distance is greater then goodNpcRange
rem then we tell the goodNpcs to follow the player
   if goodNpc(i).Distance > goodNpcRange
rem if goodNpc(i).goodNpcState = 0 it means follow the player
      goodNpc(i).goodNpcState = 0
   endif

rem if distance is less then goodNpcRange and distance is greater then goodNpcRange2
rem scout the area, and move random, then look around for the badNpcs
   if goodNpc(i).Distance < goodNpcRange and goodNpc(i).Distance > goodNpcRange2
rem if goodNpc(i).goodNpcState = 1 it means scout the area, and move random, then look around for bad guys
      goodNpc(i).goodNpcState = 1
   endif

rem if Distance2 is less than goodNpcRange4 and Distance is < than goodNpcRange
rem It means if a badNpc is around then go in attack mode.
rem then point, aim, and fire at the bad guys
   if goodNpc(i).Distance2 < goodNpcRange4 and goodNpc(i).Distance < goodNpcRange
rem if goodNpc(i).goodNpcState = 2
rem It means if a badNoc is around attack, and fire at them
      goodNpc(i).goodNpcState = 2
   else
rem else if distance2 is greater than goodNpcRange4 and Distance is less than goodNpcRange
rem go back to scout mode
      if goodNpc(i).Distance2 > goodNpcRange4 and goodNpc(i).Distance < goodNpcRange
rem if goodNpc(i).goodNpcState = 1 then return to scout mode
         goodNpc(i).goodNpcState = 1
      endif
   endif

endfunction

function GoodNpc_Distance_Formulas(i as integer)
rem we make are distance formulas
   for j = 0 to badNpcs-i
rem make this distance formula, because we need this to point the blue team at the player
      goodNpc(i).Distance = sqrt((goodNpc(i).X-player.X)^2+(goodNpc(i).Z-player.Z)^2)
rem make this distance formula, because it's needed for the red team to  point at the blue team.
      goodNpc(i).Distance2 = sqrt((goodNpc(i).X-badNpc(j).X)^2+(goodNpc(i).Z-badNpc(j).Z)^2)
rem without this it wouldn't update the positions or rotations
      position object badNpc(j).ObjNum,badNpc(j).X,badNpc(j).Y,badNpc(j).Z
   next j
endfunction

function GoodNpc_Follow_The_Player(i as integer)
rem to make the goodNpc follow the player we need to see a range to cut them off
rem we now say if goodNpc Distance is greater then goodNpcRange
rem we need to make the goodNpc follow the player if the distance is greater range
   if goodNpc(i).Distance > goodNpcRange
rem we now use are point at  player function
rem this is how we point the goodNpc at the player
rem this is 10X faster then point object, so this gives us better performance
rem were getting the point betwween the goodNpc x, and player x
      goodNpcDistanceX = (goodNpc(i).X-player.X)
rem were getting the point betwween the goodNpc z, and player z
      goodNpcDistanceZ = (goodNpc(i).Z-player.Z)
rem we then put are formula's in the atanfull to get the angle between to objects
      goodNpc(i).Angle = atanfull(goodNpcDistanceX,goodNpcDistanceZ)
   endif
endfunction

function GoodNpc_Do_Random_Movement(i as integer)
rem this says if direction = 1 then move forward
   if goodNpc(i).Direction = 1 then goodNpc(i).Z = goodNpc(i).Z + goodNpc(i).Speed
rem this says if direction = 2 then move backwards
   if goodNpc(i).Direction = 2 then goodNpc(i).Z = goodNpc(i).Z - goodNpc(i).Speed
rem this says if direction = 3 then move right
   if goodNpc(i).Direction = 3 then goodNpc(i).X = goodNpc(i).X + goodNpc(i).Speed
rem this says if direction = 4 then move left
   if goodNpc(i).Direction = 4 then goodNpc(i).X = goodNpc(i).X - goodNpc(i).Speed

rem this says turn the npc clockwise
   if goodNpc(i).Rotate = 1 then goodNpc(i).Angle = goodNpc(i).Angle + 3.141
rem this says turn the npc counter-clockwise
   if goodNpc(i).Rotate = 2 then goodNpc(i).Angle = goodNpc(i).Angle - 3.141
rem make timer, and count 1000 milliseconds
rem if it counts 1000 miliseconds then run this code goodNpc(i).Rotate = rnd(1)+1
   if timer()-goodNpc(i).RotationTimer >1000
rem use a random turn left, right or stop
        goodNpc(i).Rotate = rnd(1)+1
rem update the RotationTmer so it works
       goodNpc(i).RotationTimer = timer()
      endif
rem updates are rotation
      yrotate object goodNpc(i).ObjNum,goodNpc(i).Angle
rem if timer greater than 200 milliseconds then choose a random direction
rem notice I have more then 4 directions in there. I have rnd(16)+1 which means 17 directions
rem that's, because I want my team mates to stop moving also.
   if timer()-goodNpc(i).DirectionTimer> 200
rem this changes the new direction
      goodNpc(i).Direction = rnd(16)+1
rem update timer so it works
      goodNpc(i).DirectionTimer = timer()
   endif
endfunction


function Move_GoodNpc(i as integer)
rem this is how we calculate the right angle to move
rem were setting are angle rule to move forward
      if wrapvalue(goodNpc(i).Angle) >= 90 and wrapvalue(goodNpc(i).Angle) <= 270
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move backwards
      if wrapvalue(goodNpc(i).Angle) < 90 and wrapvalue(goodNpc(i).Angle) >=0
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move backwards
      if wrapvalue(goodNpc(i).Angle) < 360 and wrapvalue(goodNpc(i).Angle) >= 270
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move left
     if wrapvalue(goodNpc(i).Angle) >= 0 and wrapvalue(goodNpc(i).Angle) <= 180
         goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move right
      if wrapvalue(goodNpc(i).Angle) >= 180 and wrapvalue(goodNpc(i).Angle) <= 360
        goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem updates angles so it works
      yrotate object goodNpc(i).ObjNum,goodNpc(i).Angle
endfunction


function GoodNpc_Stay_Inbounds(i as integer)
rem this keeps are goodNpc's from going out of bounds
rem if Distance is greater then goodNpcRange3 and distance is less then goodNpcRange2
rem then  start going back to following the player
   if goodNpc(i).Distance > goodNpcRange3 and goodNpc(i).Distance < goodNpcRange2
rem were setting are angle rule to move forward
      if wrapvalue(goodNpc(i).Angle) >= 90 and wrapvalue(goodNpc(i).Angle) <= 270
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move backwards
      if wrapvalue(goodNpc(i).Angle) < 90 and wrapvalue(goodNpc(i).Angle) >=0
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move backwards
      if wrapvalue(goodNpc(i).Angle) < 360 and wrapvalue(goodNpc(i).Angle) >= 270
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move left
      if wrapvalue(goodNpc(i).Angle) >= 0 and wrapvalue(goodNpc(i).Angle) <= 180
         goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move right
      if wrapvalue(goodNpc(i).Angle) >= 180 and wrapvalue(goodNpc(i).Angle) <= 360
        goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem updates angles so it works
      yrotate object goodNpc(i).ObjNum,goodNpc(i).Angle
   endif

endfunction

function GoodNpc_Bullet_Respawn()
rem this is how to make a bullet respawn
rem use this local variable to do something cool
   goodNpcBulletRespawn as integer

   for j = 0 to goodNpcs
rem we use this method i = i + 1 if i greater then are bullets then i = 0
rem tells us to start over, and keep checking through are array
       i = i + 1
       if i > goodNpcBullets then i = 0
rem if goodNpcBulletRespawn equals 0 and Bullet Alive = 0
       if goodNpcBulletRespawn = 0 and goodNpcBullet(i).Alive = 0
rem bullet alive = 1, because we found a bullet
          goodNpcBullet(i).Alive = 1
rem Range = 0 to set this, so if the bullet doesn't hit a bad guy
rem we use a counter to kill the bullet if not the bullet keeps going
          goodNpcBullet(i).Range = 0
rem give the bullet position the goodNpc position
          goodNpcBullet(i).X = goodNpc(j).X
          goodNpcBullet(i).Z = goodNpc(j).Z
rem now we point are bullet at the bad npc
          GoodNpcBullet_Point_At_BadNpc(i)
rem we show the bullet
          show object goodNpcBullet(i).ObjNum
rem goodNpcBulletRespawn = 1 what this does it makes sure it only grabs 1 bullet at a time
rem so we don't get any bugs that's why I needed that local variable there
          goodNpcBulletRespawn = 1
       endif
rem without this it wouldn't update the positions or rotations
       position object  goodNpc(j).ObjNum,goodNpc(j).X,goodNpc(j).Y,goodNpc(j).Z
   next j
endfunction

function GoodNpc_Move_Bullet(i as integer)
rem we now move are goodNpc bullet
rem if bullet Alive equals 1 then start moving the bullet
   if goodNpcBullet(i).Alive = 1
rem this is are counter Range start increasing its value
      goodNpcBullet(i).Range = goodNpcBullet(i).Range + 1
rem this moves are bullet at the angle of are bad npc and uses the old position so
rem the angle doesn't update like a missle following the bad npc
      goodNpcBullet(i).X = goodNpcBullet(i).X - ( sin( wrapvalue(goodNpcBullet(i).Angle ) ) *  goodNpcBullet(i).Speed )
      goodNpcBullet(i).Z = goodNpcBullet(i).Z - ( cos( wrapvalue(goodNpcBullet(i).Angle ) ) *  goodNpcBullet(i).Speed )
   endif
endfunction

function GoodNpc_Bullet_Stay_Inbounds(i as integer)
rem this makes sure are bullet stays inbounds
rem like frome xample if bullet doesn't hit a bad guy it keeps going so we
rem must tell it to destroy the bullet if it does hit a bad guy
   for j = 0 to goodNpcs-i
rem bullet is alive
      if goodNpcBullet(i).Alive = 1
rem are counter which is Range is greater then 80 bullet dies
         if goodNpcBullet(i).Range > 80
rem we set bullet alive to 0, and range to 0
            goodNpcBullet(i).Alive = 0
            goodNpcBullet(i).Range = 0
rem we position the bullet back at goodNpc
            goodNpcBullet(i).X = goodNpc(j).X
            goodNpcBullet(i).Z = goodNpc(j).Z
rem we hide the buller because its destroyed
            hide object goodNpcBullet(i).ObjNum
         endif
rem without this it wouldn't update the positions or rotations
         position object goodNpc(j).ObjNum,goodNpc(j).X,goodNpc(j).Y,goodNpc(j).Z
      endif
   next j
endfunction


function GoodNpc_Bullet_Collision(i as integer)
rem we use this to detect if it its a bad guy
   for j = 0 to badNpcs-i
rem if distance is less then 1 then we have a collision with a bad npc
         if goodNpcBullet(i).Distance < 1
rem kill bullet
            goodNpcBullet(i).Alive = 0
rem reset are counter to range to 0
            goodNpcBullet(i).Range = 0
rem if bullet is dead
            if goodNpcBullet(i).Alive = 0
rem decrease health by 1, and make sure health doesn't go below 0
               `badNpc(j).Health = badNpc(j).Health - 1
               `if badNpc(j).Health <= -1 then badNpc(j).Health = 0
rem hide object because bullet is dead
               hide object goodNpcBullet(i).ObjNum
            endif
         endif
rem if Health = 0 then the bad npc is dead
         `if badNpc(j).Health = 0
rem just move the bad npc out of the way
           ` badNpc(j).X = -9999
           ` badNpc(j).Z = -9999
        ` endif
rem without this it wouldn't update the positions or rotations
         position object  badNpc(i).ObjNum,badNpc(i).X,badNpc(i).Y,badNpc(i).Z
   next j
endfunction

function GoodNpc_Fire_Bullet(i as integer)
rem make a timer each 200 millisecond's get a new bullet
      if timer()-goodNpcBulletTime> 200
rem we respawn the bullet
         GoodNpc_Bullet_Respawn()
rem update the timer so it works
         goodNpcBulletTime = timer()
      endif
endfunction

function Update_All_BadNpc_Settings()
rem this updates all of the badNpc settings
rem note I didn't add no ai states in the bad npc, so the code is just there
   for i = 0 to badNpcs
rem this moves the bad npc randomly
     BadNpc_Npc_Move_Random(i)
rem this makes sure the bad npc stays inbounds
     BadNpc_Npc_Stay_Inbounds(i)
      `BadNpc_Point_At_GoodNpc(i)
rem this is are bad npc distance formulas
     BadNpc_Distance_Formulas(i)
rem this tells us if a bad npc is dead respawn it
     BadNpc_Respawn(i)
rem without this it wouldn't update the positions or rotations
      yrotate object badNpc(i).ObjNum,badNpc(i).Angle
      position object badNpc(i).ObjNum,badNpc(i).X,badNpc(i).Y,badNpc(i).Z
   next i
endfunction

function BadNpc_Respawn(i as integer)
rem if health  = 0 then respawn the bad npc
   if badNpc(i).Health = 0
rem give the bad npc health so there alive again
      badNpc(i).Health = 1
rem position the bad npc at a random location
      badNpc(i).X = -rnd(30)+rnd(30)
      badNpc(i).Z = -rnd(30)+rnd(30)
   endif
endfunction

function BadNpc_Npc_Move_Random(i as integer)
rem this tells the bad npcs which way to move
rem if direction = 1 move forward
if badNpc(i).Direction = 1 then badNpc(i).Z = badNpc(i).Z + badNpc(i).Speed
rem if direction = 2 move backwards
if badNpc(i).Direction = 2 then badNpc(i).Z = badNpc(i).Z - badNpc(i).Speed
rem if direction = 3 move right
if badNpc(i).Direction = 3 then badNpc(i).X = badNpc(i).X + badNpc(i).Speed
rem if direction = 4 move left
if badNpc(i).Direction = 4 then badNpc(i).X = badNpc(i).X - badNpc(i).Speed
rem we make a timer to say each 2000 milliseconds change the bad npcs direction
   if timer()-badNpc(i).RandomTimer > 2000
rem pick a random direction
      badNpc(i).Direction = rnd(3)+1
rem update the timer so it works
      badNpc(i).RandomTimer = timer()
   endif
endfunction

function BadNpc_Distance_Formulas(i as integer)
rem this is are badnpcs distance formulas
   for j = 0 to goodNpcs-i
rem this gets the distance from the bad npcs to the good npcs
      badNpc(i).Distance = sqrt((badNpc(i).X-goodNpc(j).X)^2+(badNpc(i).Z-goodNpc(j).Z)^2)
rem this points the bad npcs at the good npcs if its less then badNpcRange
      if badNpc(i).Distance <  badNpcRange
rem point at the good npcs
         BadNpc_Point_At_GoodNpc(i)
      endif
rem without this it wouldn't update the positions or rotations
      position object goodNpc(j).ObjNum,goodNpc(j).X,goodNpc(j).Y,goodNpc(j).Z
   next j
endfunction


function BadNpc_Npc_Stay_Inbounds(i as integer)

rem this is are tempary stay in bounds area
rem if bad npc goes farther than 30
rem  then change the bad npc direction, so the bad npc goes left
if badNpc(i).X > 30
rem make the bad npc go left
    badNpc(i).Direction = 4
endif
rem if bad npc goes less than -30
rem  then change the bad npc direction, so the bad npc goes right
if badNpc(i).X < -30
rem make the bad npc go right
    badNpc(i).Direction = 3
endif
rem if bad npc goes farther than 30
rem  then change the bad npc direction, so the bad npc goes backwards
if badNpc(i).Z > 30
rem makes the bad npc to backwards
    badNpc(i).Direction = 2
endif
rem if bad npc goes less than -30
rem  then change the bad npc direction, so the bad npc goes forward
if badNpc(i).Z < -30
rem makes the bad npc to forward
    badNpc(i).Direction = 1
endif

endfunction

function BadNpc_Point_At_GoodNpc(i as integer)
rem this is how we point the goodNpc at the player
rem this is 10X faster then point object, so this gives us better performance
rem were getting the point between the badNpc, and goodNpc
   for j = 0 to  goodNpcs-i
rem were getting the point betwween the badNpc x, and goodNpc x
       badNpc(i).DistanceX = (badNpc(i).X-goodNpc(j).X)
rem were getting the point betwween the badNpc z, and goodNpc z
      badNpc(i).DistanceZ = (badNpc(i).Z-goodNpc(j).Z)
rem we then put are formula's in the atanfull to get the angle between to objects
       badNpc(i).Angle = atanfull(badNpc(i).DistanceX ,badNpc(i).DistanceZ)
    next j
endfunction

function GoodNpc_Point_At_BadNpc(i as integer)
rem this is how we point the goodNpc at the player
rem this is 10X faster then point object, so this gives us better performance
rem were getting the point betwween the goodNpc x, and player x
`if goodNpc(i).Rotate = 0
   for j = 0 to  badNpcs-i
      goodNpc(i).Distance2X = (goodNpc(i).X-badNpc(j).X)
rem were getting the point betwween the goodNpc z, and player z
      goodNpc(i).Distance2Z = (goodNpc(i).Z-badNpc(j).Z)
rem we then put are formula's in the atanfull to get the angle between to objects
      goodNpc(i).Angle = atanfull(goodNpc(i).Distance2X ,goodNpc(i).Distance2Z)
      yrotate object goodNpc(i).ObjNum,goodNpc(i).Angle
rem we update the goodNpc Angle so it works right
      position object  badNpc(j).ObjNum,badNpc(j).X,badNpc(j).Y,badNpc(j).Z
   next j
endfunction

function GoodNpcBullet_Point_At_BadNpc(i as integer)
rem this is how we point the goodNpcBullet at the badNpc
rem this is 10X faster then point object, so this gives us better performance
rem were getting the point betwween the goodNpcBullet, and badNpc
    for j = 0 to badNpcs-i
rem were getting the point betwween the goodNpcBullet x, and badNpc x
      goodNpcBullet(i).DistanceX = (goodNpcBullet(i).X-badNpc(j).X)
rem were getting the point betwween the goodNpcBullet x, and badNpc x
      goodNpcBullet(i).DistanceZ = (goodNpcBullet(i).Z-badNpc(j).Z)
rem were getting the point betwween the
rem we then put are formula's in the atanfull to get the angle between to objects
      goodNpcBullet(i).Angle = atanfull(goodNpcBullet(i).DistanceX ,goodNpcBullet(i).DistanceZ)
rem we update the badNpc Angle so it works right
      position object badNpc(j).ObjNum,badNpc(j).X,badNpc(j).Y,badNpc(j).Z
    next j
endfunction

function Debugg_Program()
rem all debugg goes here
rem shows the ai modes
   for  i= 0 to goodNpcs
      if goodNpc(i).goodNpcState = 0
         text 20,20*i,"goodNpc "+str$(i)+" No threat Mode: "`+str$(goodNpc(i).goodNpcState)
      endif

      if goodNpc(i).goodNpcState = 1
         text 20,20*i,"goodNpc "+str$(i)+" Scout Mode: "`+str$(goodNpc(i).goodNpcState)
      endif

      if goodNpc(i).goodNpcState = 2
         text 20,20*i,"goodNpc "+str$(i)+ " Attack Mode: "`+str$(goodNpc(i).goodNpcState)
      endif
   next i

endfunction


