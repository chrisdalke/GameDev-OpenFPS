rem make the good npcs for OpenFPS
rem delcare variables
global timerBasedTimer as integer = timer()
global goodNpcDistanceX as integer
global goodNpcDistanceZ as integer
global goodNpcDirectionFlag as integer

global goodNpcRange as float
goodNpcRange = 10.0

global goodNpcRange2 as float
goodNpcRange2 = 5.0

global range3 as float
goodNpcRange3 = 3.0

rem are player type
   type PlayerType
      ObjNum as integer
      X as float
      Y as float
      Z as float
      AngleX as float
      AngleY as float
      AngleZ as float
      Distance as Float
   endtype
rem this is are name of are player type were going to use
   global player as  PlayerType

rem are team mate npc type
   type GoodNpcType
      ObjNum as integer
      X as float
      Y as float
      Z as float
      Speed as float
      Distance as Float
      Distance2 as float
      Angle as float
      Angle2 as float
      Rotate as integer
      Direction as integer
      Flag as integer
      NpcMoveFlag as integer
      DirectionTimer as integer = timer()
      RotationTimer as integer = timer()
   endtype
   global goodNpcs as integer
   goodNpcs = 7
rem this is are name of are team mate npc type were going to use
   dim goodNpc(goodNpcs) as GoodNpcType

rem load ai demo
   Load_Demo()
rem run ai demo
   Run_Demo()

function Load_Players_And_Good_Npc()
   Make_Player()
   Make_Good_Npc()
endfunction

function Make_Player()

rem giving are player some variable values
rem this is are player number were going to use
   player.ObjNum = 1
rem this is are player position variable values
   player.X = 0
   player.Y = 0
   player.Z = 10
rem now we make the player
   make object cube  player.ObjNum,1
   color object player.ObjNum,rgb(255,255,0)
rem we put are player variable values in to update the position of the player
rem without this it wouldn't update
   position object player.ObjNum,player.X,player.Y,player.Z

endfunction

function Make_Good_Npc()

rem were going to have 8 to 12 good npc team members helping us
rem this is how we make are good npc
rem were giving are good npc some variable values
for i = 0 to goodNpcs
rem this is are good npc number were going to use
rem notice i+2 this means it goes from i = 2 to 9, because player.objNum = 1 we can't have 1
   goodNpc(i).ObjNum = i+2
rem this is are good npc position variable values
rem this spreads them out for now so they don't touch each other at the start
   goodNpc(i).X = -7+i*2
   goodNpc(i).Y = 0
rem this moves them behind each other in a random fashion
   goodNpc(i).Z = rnd(5)
rem this is are good npc speed how fast they will move first
   goodNpc(i).Speed = 0.2
rem now we make the good npc
   make object cube  goodNpc(i).ObjNum,1
   color object goodNpc(i).ObjNum,rgb(0,0,255)
rem we put are good npc variable values in to update the position of the good npc
rem without this it wouldn't update
   position object  goodNpc(i).ObjNum,goodNpc(i).X,goodNpc(i).Y,goodNpc(i).Z
next i

endfunction

function Load_Demo_Display()
rem this isn't important were only using this to show off the npc's this won't be in the game.
   hide mouse
   sync on
   set display mode 1024,768,screen depth()
   backdrop on
   color backdrop 0,rgb(100,100,100)
endfunction


Function Use_Demo_Camera()
rem this isn't important  were only using this to show off the npc's this won't be in the game.
   camX# = WrapValue(camera Angle X() + MouseMoveY())
   camY# = WrapValue(camera Angle Y() + MouseMoveX())
   camZ# = wrapvalue(camera Angle Z())

   rotate camera camX#,camY#,camZ#
   if mouseclick()=1 then move camera 0,1
   if mouseclick()=2 then move camera 0,-1

EndFunction

function Control_Player()

rem if the player presses W then move the player forward
   if keystate(17)=1 then player.Z = player.Z + 0.4
rem if the player presses S then move the player backwards
   if keystate(31)=1 then player.Z = player.Z - 0.4
rem if the player presses D then move the player right
   if keystate(32)=1 then player.X = player.X + 0.4
rem if the player presses A then move the player left
   if keystate(30)=1 then player.X = player.X - 0.4

endfunction

function Update_Player()
rem make sure we update the players position, and rotation
   rotate object player.ObjNum,player.AngleX,player.AngleY,player.AngleZ
   position object player.ObjNum,player.X,player.Y,player.Z
endfunction

function Update_All_Player_Settings()
rem this controls are play movements
    Control_Player()
rem this makes sure are player movements are getting updated
    Update_Player()
endfunction

function Load_Demo()
rem load are display
   Load_Demo_Display()
rem load are player and goodNpc
   Load_Players_And_Good_Npc()
endfunction

function Run_Demo()
position camera 0,50,0
point camera 0,0,0
rem this is are game up
do
rem this is how we make a timerBased Movement
rem if timer() minus timerBasedTimer this equals 0 then we say is it greater then 16
rem 1000/60 the 1000 is 1 second, and 60 is 60 fps. anways
rem 1000/60 equals 16.66666666666667  we just round this to 16.
rem this makes sure the game runs at this speed on everyones pc.
   if timer()-timerBasedTimer > 16
rem we put all are code we want to run here

      Use_Demo_Camera()
      Update_All_Player_Settings()
      Update_All_GoodNpc_Settings()

rem this updates are timerBasedTimer making sure its working.
      timerBasedTimer = timer()
   endif
rem we put are debugg function outside so we can see the real fps if not its 60 fps lol
   Debugg_Program()
rem this makes sure everything gets drawn
sync
rem this is the end of are game loop
loop
endfunction

function Update_All_GoodNpc_Settings()
rem this updates all of the goodNpc settings
   for i = 0 to goodNpcs
rem this is what makes the goodNpc move
      Move_GoodNpc(i)
rem this is how we make the goodNpc follow the player
      GoodNpc_Follow_The_Player(i)
rem this makes sure are goodNpc stay in bounds, and not get out of bounds
      GoodNpc_Stay_Inbounds(i)
rem updates all the goodNpc positions
      position object  goodNpc(i).ObjNum,goodNpc(i).X,goodNpc(i).Y,goodNpc(i).Z
   next i
endfunction


function GoodNpc_Point_At_Player(i as integer)
rem this is how we point the goodNpc at the player
rem this is 10X faster then point object, so this gives us better performance
rem were getting the point betwween the goodNpc x, and player x
      goodNpcDistanceX = (goodNpc(i).X-player.X)
rem were getting the point betwween the goodNpc z, and player z
      goodNpcDistanceZ = (goodNpc(i).Z-player.Z)
rem we then put are formula's in the atanfull to get the angle between to objects
      goodNpc(i).Angle = atanfull(goodNpcDistanceX,goodNpcDistanceZ)
rem we update the goodNpc Angle so it works right
      yrotate object goodNpc(i).ObjNum,goodNpc(i).Angle
endfunction

function GoodNpc_Follow_The_Player(i as integer)
rem to make the goodNpc follow the player we need to see a range to cut them off
rem we mae are distance formula
    goodNpc(i).Distance = sqrt((goodNpc(i).X-player.X)^2+(goodNpc(i).Z-player.Z)^2)
rem we now say if goodNpc Distance is greater then goodNpcRange
rem we need to make the goodNpc follow the player if the distance is greater range
   if goodNpc(i).Distance > goodNpcRange
rem we now use are point at  player function
      GoodNpc_Point_At_Player(i)
rem we then use this flag to tell the goodNpc to start moving from are Move_GoodNpc() function
      goodNpc(i).NpcMoveFlag = 1
   else
rem we use else to go for a different result if the goodNpc distance is less then goodNpcRange and distance is greater then goodNpcRange2
rem we use goodNpcMoveFlag = 2 makes them use a random direction
      if goodNpc(i).Distance < goodNpcRange and goodNpc(i).Distance > goodNpcRange2
rem we use goodNpcMoveFlag = 2 so the goodNpc's are close, and less the goodNpcRange2 we say start moving random
         goodNpc(i).NpcMoveFlag = 2
      endif
   endif
endfunction


function Move_GoodNpc(i as integer)
rem this says if direction = 1 then move forward
   if goodNpc(i).Direction = 1 then goodNpc(i).Z = goodNpc(i).Z + goodNpc(i).Speed
rem this says if direction = 2 then move backwards
   if goodNpc(i).Direction = 2 then goodNpc(i).Z = goodNpc(i).Z - goodNpc(i).Speed
rem this says if direction = 3 then move right
   if goodNpc(i).Direction = 3 then goodNpc(i).X = goodNpc(i).X + goodNpc(i).Speed
rem this says if direction = 4 then move left
   if goodNpc(i).Direction = 4 then goodNpc(i).X = goodNpc(i).X - goodNpc(i).Speed
rem this says turn the npc clockwise
   if goodNpc(i).Rotate = 1 then goodNpc(i).Angle2 = goodNpc(i).Angle2 + 3.141
rem this says turn the npc counter-clockwise
   if goodNpc(i).Rotate = 2 then goodNpc(i).Angle2 = goodNpc(i).Angle2 - 3.141
rem if this  goodNpcMoveFlag = 1 then goodNpc's start moving
   if goodNpc(i).NpcMoveFlag = 1
rem goodNpcDirectionFlag = 0 then don't use random directions
      goodNpcDirectionFlag = 0
rem were setting are angle rule to move forward
      if wrapvalue(goodNpc(i).Angle) >= 90 and wrapvalue(goodNpc(i).Angle) <= 270
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move backwards
      if wrapvalue(goodNpc(i).Angle) < 90 and wrapvalue(goodNpc(i).Angle) >=0
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move backwards
      if wrapvalue(goodNpc(i).Angle) < 360 and wrapvalue(goodNpc(i).Angle) >= 270
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move left
     if wrapvalue(goodNpc(i).Angle) >= 0 and wrapvalue(goodNpc(i).Angle) <= 180
         goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move right
      if wrapvalue(goodNpc(i).Angle) >= 180 and wrapvalue(goodNpc(i).Angle) <= 360
        goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
   endif
rem if goodNpc(i).NpcMoveFlag = 2 wait 200 milliseconds before chooseing a new random direction or rotation
   if goodNpc(i).NpcMoveFlag = 2
rem if goodNpcMoveFlag = 2 then use a random direction
      goodNpcDirectionFlag = 1
      if timer()-goodNpc(i).RotationTimer > 200
         goodNpcDirectionFlag = 2
rem use a random turn left, right or stop
         goodNpc(i).Rotate = rnd(2)+1
rem update the RotationTmer it counts the 200 milliseconds right
         goodNpc(i).RotationTimer = timer()
      endif
rem updates are rotation
      yrotate object goodNpc(i).ObjNum,goodNpc(i).Angle2
   endif
rem if goodNpcDirectionFlag equals zero then stop the npc
   if goodNpcDirectionFlag = 0
rem we set goodNpc(i).Direction = 0 to stop the direction
      goodNpc(i).Direction = 0
   endif
rem if goodNpcDirectionFlag = 1  then wait until 1 second to change a random direction
rem note: I have rnd(30)+1 this makes the npc not move so that why I have the extra numbers
   if goodNpcDirectionFlag = 1
      if timer()-goodNpc(i).DirectionTimer > 1000
rem picks a random direction
         goodNpc(i).Direction = rnd(30)+1
rem updates the timer
         goodNpc(i).DirectionTimer = timer()
      endif
   endif
endfunction

function GoodNpc_Stay_Inbounds(i as integer)
rem this keeps are goodNpc's from going out of bounds
rem if Distance is greater then range3 and distance is less then range2 then  follow the player
   if goodNpc(i).Distance > goodNpcRange3 and goodNpc(i).Distance < goodNpcRange2
rem were setting are angle rule to move forward
      if wrapvalue(goodNpc(i).Angle) >= 90 and wrapvalue(goodNpc(i).Angle) <= 270
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move backwards
      if wrapvalue(goodNpc(i).Angle) < 90 and wrapvalue(goodNpc(i).Angle) >=0
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move backwards
      if wrapvalue(goodNpc(i).Angle) < 360 and wrapvalue(goodNpc(i).Angle) >= 270
         goodNpc(i).Z = goodNpc(i).Z - ( cos( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move left
      if wrapvalue(goodNpc(i).Angle) >= 0 and wrapvalue(goodNpc(i).Angle) <= 180
         goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
rem were setting are angle rule to move right
      if wrapvalue(goodNpc(i).Angle) >= 180 and wrapvalue(goodNpc(i).Angle) <= 360
        goodNpc(i).X = goodNpc(i).X - ( sin( wrapvalue(goodNpc(i).Angle ) ) * goodNpc(i).Speed )
      endif
   endif

endfunction


function Debugg_Program()
rem all debugg goes here
text 20,80,"fps: "+str$(screen fps())
text 20,100,"goodNpcMoveFlag: "+str$(goodNpcMoveFlag)
endfunction


