remstart
/////////////////////////////////////////////////////
//
// OpenFPS NETWORK FUNCTIONS Core Module
//
// Created by --
// Maintained by --
//
/////////////////////////////////////////////////////

----- Changelog:
(2/8/10) - BMacZero - Created
(07/06/10) - miso     - just placed logger commands
(07/06/10) - thenerd  - added commands
(07/28/10) - thenerd  - added PlayerData.cfg for player name & other info
(08/17/10) - miso     - added a display info when waiting to connect master server, not to see tha black screen
(11/29/10) - thenerd  - Restructured code to use new module layout
(07/10/11) - miso     - Rewritten the code to pure UDP, building a reliable system on top of it.
                        Code is under construction.
----- To-Do:
-None-

----- Purpose:
Communicates with host to retrieve updated information on
player, enemy, and object positions and states.
Passes this information to relevant modules to deal with it.


----- Dependancies and Conflicts (IMPORTANT STUFF):
         -Requires Winsock, Ians matrix utils-

----- Other Notes:
Chat Message Tags
&name=name           - Changes your name and displays a message.
&name_silent=name    - Changes your name without displaying a message.
&color="r,g,b"		 - Changes your chat color (WORK IN PROGRESS)
&blarg	             - :D

All functions and resources in the Network module use the prefix NET_

----- Function List:
-Client:
NET_init()			  		  - initializes the networking module
NET_update()     	  		  - updates any network data with the server.
NET_terminate()  	  		  - ends the networking module, and cleans up any used resources.
NET_getChatMessage()		  - gets the latest chat message.
NET_sendChatMessage(string$)  -	sends a chat message.

-Server variables:
DATA_MaxPlayers:	max players on server
DATA_Map:			server map
DATA_TimeLimit:		Time limit until reset
DATA_ServerType:	Type (1=Public, 2=Private LAN, 3=LoopBack interface)
DATA_PrivatePass:   Password for server (Default is blank)

remend
//---------------------------------------------------------------------------
remstart
PAcket Infos
Packet types

    1.)- TCP -Hello Master server, I'm a new participant, want to join, and I request a unique ID

	Value 	Range 	Position
Special openfps dword 	dword (45248) 	4 byte 	+0
Packet type 	word (1) 	2byte 	+4
Sender ID (0) 	Dword (0) 	4byte 	+6
PAcket ID (adress) 	Dword (memory) 	4byte 	+10
player choosen name 	byte sequence 	12byte 	+14
Total Size 	26 bytes

    2.) - TCP -Master server responds you shall not pass,
        because
            1.) there is no free unique id
            2.) your username and password is not correct
            3.) this IP is banned
            4.) unknown reason
        I recived your important packet TYPE 1

	Value 	Range 	Position
Special openfps dword 	dword (45248) 	4 byte	+0
Packet type 	word (2) 	2byte 	+4
0 	Dword 	4byte 	+6
PAcket ID (adress) 	Dword (memory) 	4byte 	+10
Total Size 	14 bytes

    3.) - TCP -Master server welcomes you, saves your unique id and display username in an array
        I send you your unique ID is this, you are now connected to master server
        Look, these players are online, and this is their username and current unique ids
        Behold - these games are running currently, there are available places for players here and here
        I recived your important packet TYPE 1

	Value 	Range 	Position
Special openfps dword 	dword (45248) 	4 byte	+0
Packet type 	word (3) 	2byte 	+4
unique id for the client 	Dword (memory) 	4byte 	+6
PAcket ID (adress) 	Dword (memory) 	4byte 	+10
Total Size 	14 bytes

    4.) - TCP -Client says So long master server, and thanks for all the fish
        I send you my unique ID is this

    5.) - TCP -Master server says Goodbye Client, I will miss you
        master server frees your unique id, client can close program

    6.) - TCP -Master server says Joy my brother clients, 'cause new client has arrived
        His name is this
        His unique ID is this, please register him as a friend.

    7.) - TCP -Master server says lament my brother clients, 'cause our old friend client has left our gray world
        His name was this
        His unique ID was this, please register he is no longer in the game.

    8.) - TCP -Master server asks clients, “Are you still there?”

    9.) - TCP -Clients report to Master Server: “I'm still here, and having fun”
        My ID is this

    10.) - TCP -Clienst asks permission from the great master server to send a message to the chatboard
        My ID is this
        My humble message would be this

    11.) - TCP -Master server say to clients not in play, that client sent a message to the chatboard
        His ID is this
        His humble message would be this

    12.) - TCP -Client asks permission from master server to upgrade himself into a hosting client
        Look, my unique ID is this
        I choosed a gameplay type of this
        there will be place for new players up to x.
        The starting map would be map ID x.

    13.) - TCP -Master server says:permission granted, start your client host job, report me when its up
        I will give you a gamehost ID of x.
        Please report when the host is up, and i will display you on the game board

    14.) - TCP -Hosting Client report to master server, thank you, my game is running, im awaiting players
    My unique id is this
    My game ID is this
    maximum number of players is this
    number of currently joined players are this

    15.) - TCP -Client pings for masterservers, checking online status
        I request an Ack, that you are online, i have this packet in memory
        I send you a special id of my packet (the memory adress i hold this)
Remend
//---------------------------------------------------------------------------

`=========Constants=========`
//--Winsock error codes
#constant NET_WSAECONNRESET 10054

//IPs and Ports
#constant NET_LOCALHOST             = "127.0.0.1"
#constant NET_MASTERSERVER          = "127.0.0.1"

// client-master send-receive channel array id
#constant NET_MS                    = 1
#constant NET_MR                    = 2
#constant NET_CS                    = 3
#constant NET_CR                    = 4

//--participanttypes
#Constant NET_N=0 :`Im nothing yet
#Constant NET_M=1 :`master server
#Constant NET_C=2 :`client
#Constant NET_B=3 :`both

//FIX DATA
#constant NET_MTU = 256
#constant NET_MAXCLIENTS = 256
#constant NET_MAXUSERS   = 256 :`same

`===========================`
`==========Globals==========`

// PORTS
GLOBAL NET_MSPORT as integer :`master servers port for sending
GLOBAL NET_MRPORT as integer :`master servers port for receiving (send port+1)
GLOBAL NET_CSPORT as integer :`clients port for sending
GLOBAL NET_CRPORT as integer :`clients port for receiving (send port+1)
GLOBAL CLIENT_USERNAME as string

// NET INFOS
GLOBAL NET_MYIP      as String
GLOBAL NET_MYPORT    as Integer
Global NET_mystatus  as byte
GLOBAL NET_PP        as integer : `packets pending
GLOBAL NET_CA        as integer : `channels allocated
GLOBAL NET_PA        as integer : `Participants allocated

// NET INTERNAL VARIABLES
Global NET_PEEK      as dword
Global NET_POKE      as dword
GLOBAL NET_OPENFPSID as dword
GLOBAL NET_PACKETID  as word

GLOBAL NET_WORD     as word
GLOBAL NET_DWORD    as dword
GLOBAL NET_INTEGER  as integer
GLOBAL NET_BYTE     as byte
GLOBAL NET_FLOAT    as float
Global test_recived as dword
Global test_sent as dword
`===========================`

`===========Types===========`
Type NET_Gametype
     ID         as Dword
     HOSTID     as Dword
     Port       as Integer
     Map        as dword
     MaxPlayers as byte
     Players    as byte
Endtype
`===========================

`=========FUNCTIONS=========`


Function NET_StartWinsock()
//*****************************************************
//*   Miso                                             
//*     Starts winsock, creates the basic arrays needed
//*
//*****************************************************
    //--start winsock
    writeln log log_line,""
   	Winsock Make
randomize timer()
   	//--Creates arrays, 0 elements will be used for temporary datas
   	//--creates arrays for channels
   	NET_CA = 4 :`(channels allocated)
   	dim NET_CHANNEL(4)         as Dword
   	dim NET_CHANNEL_IP(4)         as STRING
   	DIM NET_CHANNEL_PORT(4)       AS INTEGER
   	
   	//--creates arrays for packets   	
   	NET_PP = 0 :`(packets pending)
   	dim NET_PACKET_ADRESS(0)       as DWORD
   	dim NET_PACKET_LENGTH(0)       as DWORD
   	dim NET_PACKET_REMOTEIP(0)     as STRING
   	dim NET_PACKET_REMOTEPORT(0)   as INTEGER
   	dim NET_PACKET_STATUS(0)       as byte
   	dim NET_PACKET_tickerid(0)     as integer
   	dim NET_PACKET_RESENT(0)       as word
  	
   	//--creates array for participants
   	NET_PA = 0 :`(participants allocated)
   	dim NET_PARTICIPANT_ID(0)      as dword
   	dim NET_PARTICIPANT_name(0)    as string
   	dim NET_PARTICIPANT_IP(0)      as string
    dim NET_PARTICIPANT_port(0)    as integer
    dim NET_PARTICIPANT_status(0)  as byte
    dim NET_PARTICIPANT_gameid(0)  as integer
    
    //--servers
    dim servers(24,3) as string
    
    
    //--setup basic data
    NET_MYIP=NET_LOCALHOST
     rem net_getmypublicipfullsearch()
    NET_OPENFPSID    = 45248
    NET_MSPORT=5000
    NET_MRPORT=5001 :`receivers ports are always next to the senderport
Endfunction


Function NET_CloseWinsock()
//*******************************************************************
//*   Miso                                             
//*     Closes winsock, deletes channels if exists, deallocate arrays
//*
//*******************************************************************

	//--delete channels
	If NET_CHANNEL(1)<>0 then winsock delete channel NET_CHANNEL(1)
	If NET_CHANNEL(2)<>0 then winsock delete channel NET_CHANNEL(2)
	If NET_CHANNEL(3)<>0 then winsock delete channel NET_CHANNEL(3)
	If NET_CHANNEL(4)<>0 then winsock delete channel NET_CHANNEL(4)
	//--undim channels array
	undim NET_CHANNEL_ID(0):NET_CHANNELS_ALLOCATED=0
	//--winsock cleanup
	winsock clean up
   	NET_CA = 0 :`(channels allocated)
   	undim NET_CHANNEL(0)            : undim NET_CHANNEL_IP(0)
   	undim NET_CHANNEL_PORT(0)       :
   	NET_PP = 0 :`(packets pending)
   	//--frees dummy memory

   	undim NET_PACKET_ADRESS(0)      : undim NET_PACKET_LENGTH(0)
   	undim NET_PACKET_REMOTEIP(0)    : undim NET_PACKET_REMOTEPORT(0)
   	undim NET_PACKET_STATUS(0)      : undim NET_PACKET_tickerid(0)
   	undim NET_PACKET_RESENT(0)      :
  	NET_PA = 0 :`(participants allocated)
   	undim NET_PARTICIPANT_ID(0)     : undim NET_PARTICIPANT_IP(0)
    undim NET_PARTICIPANT_port(0)   : undim NET_PARTICIPANT_status(0)
    undim NET_PARTICIPANT_gameid(0) :
    
    //--undim servers datalist
    undim servers(0)
	writeln log log_black,get date$()+" "+get time$()+" Application gracefully exit"
	writeln log log_line,""
	
	close log
	wait 100
	
	end
	
Endfunction


Function NET_START_MASTERSERVER()
//*****************************************************
//*   Miso                                             
//*     Starts masterserver, binding sockets net_channel(3-4)
//*
//*****************************************************
//--open log
open log "server.html",1
SET LOG TAG 0, "", "<br>"
SET LOG TAG log_red, "<font color=#ff0000>", "</font><br>"
SET LOG TAG log_yellow, "<font color=#0f0f00>", "</font><br>"
SET LOG TAG log_green, "<font color=#008800>", "</font><br>"
SET LOG TAG log_black, "<font color=#000000>", "</font><br>"
SET LOG TAG log_line, "<hr width=100% size=10 noshade />", ""
SET LOG TAG log_thinline, "<hr width=100% size=3 noshade />", ""


	//create server port for receiving
	NET_CHANNEL(net_ms)=WINSOCK CREATE UDP CHANNEL()
	WINSOCK BIND CHANNEL NET_CHANNEL(net_ms),NET_MYIP,NET_MSPORT
	net_errorcheck(NET_CHANNEL(net_ms))
	//create server port for sendint
	NET_CHANNEL(net_mr)=WINSOCK CREATE UDP CHANNEL()
	WINSOCK BIND CHANNEL NET_CHANNEL(net_mr),NET_MYIP,NET_MRPORT
	net_errorcheck(NET_CHANNEL(net_mr))
	NET_Mystatus=NET_M

	//--placing log commands
	writeln log log_black,get date$()+" "+get time$()+" Master server started."
	writeln log log_thinline,""
	writeln log log_black,"IP          :"+net_myip
	writeln log log_black,"Receive Port: "+str$(net_mrport)
	writeln log log_black,"Send Port   : "+str$(net_msport)
	writeln log log_thinline,""
Endfunction



Function NET_CLOSE_MASTERSERVER()
//*****************************************************
//*   Miso                                             
//*     closes masterserver
//*
//*****************************************************

	If NET_CHANNEL(net_ms)<>0 
		winsock delete channel NET_CHANNEL(net_ms)
		NET_CHANNEL(net_ms)=0
			NET_Mystatus=NET_N
	Endif
	
	If NET_CHANNEL(net_mr)<>0 
		winsock delete channel NET_CHANNEL(net_mr)
		NET_CHANNEL(net_mr)=0
			NET_Mystatus=NET_N
	Endif
Endfunction


Function NET_START_IDLECLIENT()
//*****************************************************
//*   Miso                                             
//*     Starts a client
//*
//*****************************************************
//--open log
open log "client.html",1
SET LOG TAG 0, "", "<br>"
SET LOG TAG log_red, "<font color=#ff0000>", "</font><br>"
SET LOG TAG log_yellow, "<font color=#0f0f00>", "</font><br>"
SET LOG TAG log_green, "<font color=#008800>", "</font><br>"
SET LOG TAG log_black, "<font color=#000000>", "</font><br>"

	//--creates client channel for sending
	NET_CHANNEL(net_cs)=WINSOCK CREATE UDP CHANNEL()
	//--selects a high port randomly between 20k-40k
	//--I have to bind the socket, and dont know any better solution
	//--for port choice. Any better solution is welcomed.
	NET_CSPORT=20000+RND(20000)
	WINSOCK BIND CHANNEL NET_CHANNEL(net_cs),NET_MYIP,NET_CSPORT
	net_errorcheck(net_channel(net_cs))
	//--creates client channel for receiving
	NET_CHANNEL(net_cr)=WINSOCK CREATE UDP CHANNEL()
	//--receive port will be the next to NET_CSPORT
	NET_CRPORT=NET_CSPORT+1
	WINSOCK BIND CHANNEL NET_CHANNEL(net_cr),NET_MYIP,NET_CRPORT
	net_errorcheck(net_channel(net_cr))
	NET_Mystatus=NET_C
	
	writeln log log_black,"Client started at ip "+net_myip+":"+str$(net_csport)
	writeln log log_black,"Client started at ip "+net_myip+":"+str$(net_crport)
	
Endfunction

Function NET_CLOSE_IDLECLIENT()
//*****************************************************
//*   Miso                                             
//*     closes a client
//*
//*****************************************************
	If NET_CHANNEL(net_cs)<>0 
		winsock delete channel NET_CHANNEL(net_cs)
		NET_CHANNEL(net_Cs)=0
	Endif
	If NET_CHANNEL(net_cr)<>0 
		winsock delete channel NET_CHANNEL(4)
		NET_CHANNEL(net_cr)=0
	Endif
	NET_Mystatus=NET_N
Endfunction

Function NET_SERVER_RECEIVE()
//*****************************************************
//*   Miso                                             
//*     check server ports for incoming data
//*
//*****************************************************
local memoryID as dword
local tmpdword as dword
	repeat
		winsock refresh channel NET_CHANNEL(net_mr)
		if winsock channel data waiting(NET_CHANNEL(net_mr))=1
			winsock recv udp message NET_CHANNEL(net_mr)
			//--checks if the data is an openfps data
			NET_DWORD=peek dword(winsock channel data ptr(NET_CHANNEL(net_mr)))
			If net_Dword=NET_OPENFPSID
				test_recived=test_recived+1
				//--saves packet in memory
				Net_Word=Peek word(winsock channel data ptr(NET_CHANNEL(net_mr)+4))
					Select Net_Word
						//__Authentication request arrives
						case 1
						if NET_PA=0
							net_increaseparticipants()
							net_participant_id(net_pa)=make memory(4)
							net_participant_IP(net_pa)=winsock remote host$(net_channel(net_mr))
							net_participant_Port(net_pa)=winsock remote port(net_channel(net_mr))
							net_participant_status(net_pa)=0
							Poke dword net_participant_id(net_pa),peek dword(winsock channel data ptr(NET_CHANNEL(net_mr)+10))
							
							for x=0 to 11
								if peek byte(winsock channel data ptr(NET_CHANNEL(net_mr)+14+x))<>0
									net_participant_name(net_pa)=net_participant_name(net_pa)+chr$(peek byte(winsock channel data ptr(NET_CHANNEL(net_mr)+14+x)))
								endif
								
							next x
							writeln log log_green,net_participant_name(net_pa)+" joined."
							net_m_3(net_participant_ip(net_pa),net_participant_port(net_pa),peek dword(winsock channel data ptr(NET_CHANNEL(net_mr)+6)))
						else
							If net_pa<net_maxusers
								for x=1 to net_pa
									if net_participant_IP(x)=winsock remote host$(net_channel(net_mr)) and net_participant_Port(x)=winsock remote port(net_channel(net_mr))
										exitfunction
									endif
								next x
								net_increaseparticipants()
								net_participant_id(net_pa)=make memory(4)
								net_participant_IP(net_pa)=winsock remote host$(net_channel(net_mr))
								net_participant_Port(net_pa)=winsock remote port(net_channel(net_mr))
								net_participant_status(net_pa)=0
								Poke dword net_participant_id(net_pa),peek dword(winsock channel data ptr(NET_CHANNEL(net_mr)+10))
								
								for x=0 to 11
									if peek byte(winsock channel data ptr(NET_CHANNEL(net_mr)+14+x))<>0
										net_participant_name(net_pa)=net_participant_name(net_pa)+chr$(peek byte(winsock channel data ptr(NET_CHANNEL(net_mr)+14+x)))
									endif
									
								next x
								writeln log log_green,net_participant_name(net_pa)+" joined."
								net_m_3(net_participant_ip(net_pa),net_participant_port(net_pa),peek dword(winsock channel data ptr(NET_CHANNEL(net_mr)+6)))
							endif
						Endif
						
						
						endcase
						//__client alive ping arrives
						Case 15
							//send ack
							NET_PACKET_ADRESS(0)=Make Memory(14)
							NET_PACKET_REMOTEIP(0)=winsock remote host$(NET_CHANNEL(net_mr))
    						NET_PACKET_REMOTEPORT(0)=winsock remote port(NET_CHANNEL(net_mr))
    						NET_PACKET_REMOTEPORT(0)=NET_PACKET_REMOTEPORT(0)+1
    						memoryid=peek dword(winsock channel data ptr(NET_CHANNEL(net_mr)+10))

    						rem poke word(16)
    						

    						rem winsock copy channel data net_channel(net_mr),NET_PACKET_ADRESS(0)
    						
    						//--change the datatype
    						poke dword NET_PACKET_ADRESS(0),net_openfpsid
   							poke word NET_PACKET_ADRESS(0)+4,16
    						poke dword NET_PACKET_ADRESS(0)+6,0
    						poke dword NET_PACKET_ADRESS(0)+10,memoryID
    						
    						//--Send to target
    						winsock set channel target net_channel(net_ms),NET_PACKET_REMOTEIP(0),NET_PACKET_REMOTEPORT(0)
    						winsock send udp message net_channel(net_ms),NET_PACKET_ADRESS(0),14
    						test_sent=test_sent+1
    						delete memory NET_PACKET_ADRESS(0)
    						NET_PACKET_ADRESS(0)=0
						Endcase
					
					Endselect
				
				
			Endif
		Endif
	Until winsock channel data waiting(NET_CHANNEL(net_mr))=0


Endfunction

Function NET_CLIENT_RECEIVE()
//*****************************************************
//*   Miso                                             
//*     check client ports for incoming data
//*
//*****************************************************
local channeldata as dword
local remot as string
	repeat
		winsock refresh channel NET_CHANNEL(net_cr)
		if winsock channel data waiting(NET_CHANNEL(net_cr))=1
			winsock recv udp message NET_CHANNEL(net_cr)
			
			//--checks if the data is an openfps data
			channeldata=peek dword(winsock channel data ptr(NET_CHANNEL(net_cr)))
			If channeldata=NET_OPENFPSID
				test_recived=test_recived+1
				net_word=peek word(winsock channel data ptr(NET_CHANNEL(net_cr)+4))
				Select Net_word
					
					//__master server denies your join request					
					Case 2
						writeln log log_red,"MASTER SERVER DENIES YOUR AUTH REQUEST"
						net_closewinsock()
					Endcase
					
					//__master server accepts you, you are joined
					Case 3
						net_deletereliablepacket(peek dword(winsock channel data ptr(NET_CHANNEL(net_cr)+10)))
						for x=1 to 24
							//SyS_deletegadget(str$(x))
						next x
						runningmenu=c_joinedmenu
						//createjoinedmenubuttons()
						writeln log log_green,"YOU JOINED TO MASTER SERVER"
					Endcase
					
				
					//__server alive ping ack arrives
					Case 16
						Net_Dword=peek dword(winsock channel data ptr(NET_CHANNEL(net_cr)+10))
						Net_DeleteReliablepacket(Net_Dword)
						//activateservergadget(winsock remote host$(net_channel(net_cr)))
						
					Endcase
				
				    
				    
				    
				Endselect
				
				
			Endif
		Endif
	Until winsock channel data waiting(NET_CHANNEL(net_cr))=0
Endfunction

Function Net_Checkclientresends()
//*****************************************************
//*   Miso                                             
//*     check clients pending packets for resend or delete
//*
//*****************************************************
	if net_PP>0
		for lda=net_pp to 1 step -1
			if NET_PACKET_STATUS(lda)=4
				if net_packet_resent(lda)<4
					if ticker exist(net_packet_tickerid(lda))
						if ticker(net_packet_tickerid(lda),1)=1
							inc net_packet_resent(lda)
							winsock set channel target net_channel(net_cs),NET_PACKET_REMOTEIP(lda),NET_PACKET_REMOTEPORT(lda)
    						winsock send udp message net_channel(net_cs),NET_PACKET_ADRESS(lda),NET_PACKET_length(lda)
    					endif
					endif
				else
				//--we resent packets 4 times, so we delete it, no more resend
				net_deletepacket(LDA)
				
				endif
			endif
		next lda
	endif
Endfunction


`====SECONDARY FUNCTIONS====`

Function NET_DNSLOOKUP$(param_hostname$ as string)
//*****************************************************
//*   Miso                                             
//*     Secondary DNS lookup command
//*
//*****************************************************
local ret_string$ as string
    ret_string$=ip to string$(hostname to ip(param_hostname$))
Endfunction ret_string$


function NET_ERRORCHECK(a_channel as DWORD)
//*****************************************************
//*   Miso                                             
//*     Secondary errorcheck command
//*
//*****************************************************

`check for an error on a channel.
   if (winsock channel error(a_channel))
      `an error has occurred.
      `cls
      if winsock channel error nr(a_channel) = NET_WSAECONNRESET
         `this error message appears if you send UDP data to an invalid destination / where no one is waiting for it.
         `reset channel error.
         winsock reset error a_channel
         print "invalid destination"
      else
         print winsock channel error msg$(a_channel)
         wait key
         winsock clean up
         end
      endif
   endif
endfunction

Function NET_INCREASEPACKETS()
//*****************************************************
//*   Miso                                             
//*     Increases the pending packets datas by 1
//*
//*****************************************************
   	Array insert at bottom NET_PACKET_ADRESS(0)
    Array insert at bottom NET_PACKET_LENGTH(0)
   	Array insert at bottom NET_PACKET_REMOTEIP(0)
   	Array insert at bottom NET_PACKET_REMOTEPORT(0)
   	Array insert at bottom NET_PACKET_STATUS(0)
   	Array insert at bottom NET_PACKET_tickerid(0)
   	Array insert at bottom NET_PACKET_resent(0)
   	NET_PP=NET_PP+1
ENDFUNCTION

Function NET_INCREASEPARTICIPANTS()
//*****************************************************
//*   Miso                                             
//*     Increases the participant datas by 1
//*
//*****************************************************
	Array insert at bottom NET_PARTICIPANT_ID(0)
	Array insert at bottom NET_PARTICIPANT_NAME(0)
	Array insert at bottom NET_PARTICIPANT_IP(0)
	Array insert at bottom NET_PARTICIPANT_PORT(0)
	Array insert at bottom NET_PARTICIPANT_STATUS(0)
	net_pa=net_pa+1
ENDFUNCTION



Function NET_DELETEPENDINGPACKETS(param_HOST$ as string,param_port as integer,param_type as word)
Endfunction

Function NET_DELETELASTPACKET()
//*****************************************************
//*   Miso                                             
//*     Deletes the last pending packet
//*
//*****************************************************
If Net_PP>0
	Delete memory NET_PACKET_ADRESS(NET_PP)
   	Array delete element NET_PACKET_ADRESS(),NET_PP
    Array delete element NET_PACKET_LENGTH(),NET_PP
   	Array delete element NET_PACKET_REMOTEIP(),NET_PP
   	Array delete element NET_PACKET_REMOTEPORT(),NET_PP
   	Array delete element NET_PACKET_STATUS(),NET_PP
   	If Ticker exist(NET_PACKET_tickerid(NET_PP)) then delete ticker NET_PACKET_tickerid(NET_PP)
   	Array delete element NET_PACKET_tickerid(),NET_PP
   	Array delete element NET_PACKET_resent(),NET_PP
	NET_PP=NET_PP-1
Endif
Endfunction

Function NET_DELETEreliablepacket(param_adress as dword)
//*****************************************************
//*   Miso                                             
//*     Deletes pending packet by checking the stored memory adress
//*
//*****************************************************
local lda as integer
If Net_PP>0
	for lda=1 to net_pp
		if net_packet_adress(lda)=param_adress
			Delete memory NET_PACKET_ADRESS(lda)
   			Array delete element NET_PACKET_ADRESS(),lda
    		Array delete element NET_PACKET_LENGTH(),lda
   			Array delete element NET_PACKET_REMOTEIP(),lda
   			Array delete element NET_PACKET_REMOTEPORT(),lda
   			Array delete element NET_PACKET_STATUS(),lda
   			If Ticker exist(NET_PACKET_tickerid(lda)) then delete ticker NET_PACKET_tickerid(lda)
   			Array delete element NET_PACKET_tickerid(),lda
   			Array delete element NET_PACKET_resent(),lda
			NET_PP=NET_PP-1
			exitfunction
		endif
	next lda
Endif
Endfunction


Function NET_DELETEpackettype(param_type as word)
//*****************************************************
//*   Miso                                             
//*     Deletes pending packet by checking the stored memory adress
//*
//*****************************************************
local lda as integer
local var_type as word
If Net_PP>0
	for lda=1 to net_pp
		if net_packet_adress(lda)=param_adress
		var_type=peek word(net_packet_adress(lda)+4)
			if var_type=param_type
				Delete memory NET_PACKET_ADRESS(lda)
   				Array delete element NET_PACKET_ADRESS(),lda
    			Array delete element NET_PACKET_LENGTH(),lda
   				Array delete element NET_PACKET_REMOTEIP(),lda
   				Array delete element NET_PACKET_REMOTEPORT(),lda
   				Array delete element NET_PACKET_STATUS(),lda
   				If Ticker exist(NET_PACKET_tickerid(lda)) then delete ticker NET_PACKET_tickerid(lda)
   				Array delete element NET_PACKET_tickerid(),lda
   				Array delete element NET_PACKET_resent(),lda
				NET_PP=NET_PP-1
				exitfunction
			endif
		endif
	next lda
Endif
Endfunction


Function NET_DELETEpacket(param_arraycount as integer)
//*****************************************************
//*   Miso                                             
//*     Deletes pending packet by checking array position
//*
//*****************************************************
		If param_arraycount<net_PP+1 and param_arraycount>0
			Delete memory NET_PACKET_ADRESS(param_arraycount)
   			Array delete element NET_PACKET_ADRESS(),param_arraycount
    		Array delete element NET_PACKET_LENGTH(),param_arraycount
   			Array delete element NET_PACKET_REMOTEIP(),param_arraycount
   			Array delete element NET_PACKET_REMOTEPORT(),param_arraycount
   			Array delete element NET_PACKET_STATUS(),param_arraycount
   			If Ticker exist(NET_PACKET_tickerid(param_arraycount)) then delete ticker NET_PACKET_tickerid(param_arraycount)
   			Array delete element NET_PACKET_tickerid(),param_arraycount
   			Array delete element NET_PACKET_resent(),param_arraycount
			NET_PP=NET_PP-1
		endif
Endfunction





Function NET_C_15(param_IP as string,param_port as integer)
//*****************************************************
//*   Miso                                             
//*     Client Pingalive packet sending
//*
//*****************************************************
	Net_Increasepackets()
	NET_PACKET_ADRESS(NET_PP)=Make Memory(14)
	NET_PACKET_LENGTH(NET_PP)=14
    NET_PACKET_REMOTEIP(NET_PP)=param_IP
    NET_PACKET_REMOTEPORT(NET_PP)=param_PORT
    NET_PACKET_STATUS(NET_PP)=4
    NET_PACKET_tickerid(NET_PP)=find free ticker()
    make ticker NET_PACKET_tickerid(NET_PP),2500
    NET_PACKET_resent(NET_PP)=0
    winsock set channel target net_channel(net_cs),NET_PACKET_REMOTEIP(NET_PP),NET_PACKET_REMOTEPORT(NET_PP)
    //--put the data in
    poke dword NET_PACKET_ADRESS(NET_PP),net_openfpsid
    poke word NET_PACKET_ADRESS(NET_PP)+4,15
    poke dword NET_PACKET_ADRESS(NET_PP)+6,0
    poke dword NET_PACKET_ADRESS(NET_PP)+10,NET_PACKET_ADRESS(NET_PP)
    //--Send to target
    winsock send udp message Net_channel(net_cs),NET_PACKET_ADRESS(NET_PP),14
    test_sent=test_sent+1
Endfunction

Function NET_M_16(param_IP as string,param_port as integer,param_packetid as dword)
//*****************************************************
//*   Miso                                             
//*     Server ack for c15 pingalive, means im online (not used, ack has been buit in the server rec command)
//*
//*****************************************************
	NET_PACKET_ADRESS(0)=Make Memory(14)
	NET_PACKET_LENGTH(0)=14
    NET_PACKET_REMOTEIP(0)=param_IP
    NET_PACKET_REMOTEPORT(0)=param_PORT+1
    NET_PACKET_STATUS(0)=0
    winsock set channel target net_channel(net_Ms),NET_PACKET_REMOTEIP(NET_PP),NET_PACKET_REMOTEPORT(NET_PP)
    //--put the data in
    poke dword NET_PACKET_ADRESS(0),net_openfpsid
    poke word NET_PACKET_ADRESS(0)+4,16
    poke dword NET_PACKET_ADRESS(0)+6,0
    poke dword NET_PACKET_ADRESS(0)+10,param_packetid
    //--Send to target
    winsock send udp message Net_channel(NET_MS),NET_PACKET_ADRESS(0),14
    delete memory NET_PACKET_ADRESS(0)
    NET_PACKET_ADRESS(0)=0
Endfunction

Function net_c_1(param_IP as string,param_port)
//*****************************************************
//*   Miso                                             
//*     Client join request
//*
//*****************************************************
local lda as integer
if net_pp=0
	Net_Increasepackets()
	NET_PACKET_ADRESS(NET_PP)=Make Memory(26)
	NET_PACKET_LENGTH(NET_PP)=26
    NET_PACKET_REMOTEIP(NET_PP)=param_IP
    NET_PACKET_REMOTEPORT(NET_PP)=param_PORT
    NET_PACKET_STATUS(NET_PP)=4
    NET_PACKET_tickerid(NET_PP)=find free ticker()
    make ticker NET_PACKET_tickerid(NET_PP),250
    NET_PACKET_resent(NET_PP)=0
    winsock set channel target net_channel(net_cs),NET_PACKET_REMOTEIP(NET_PP),NET_PACKET_REMOTEPORT(NET_PP)
    //--put the data in
    	//--openfps dword
    	poke dword NET_PACKET_ADRESS(NET_PP),net_openfpsid
    	//--packet type
    	poke word NET_PACKET_ADRESS(NET_PP)+4,1
    	//--sender id 0
    	poke dword NET_PACKET_ADRESS(NET_PP)+6,0
    	rem poke dword NET_PACKET_ADRESS(NET_PP)+6,net_packet_adress(net_pp)
    	//--sender packet id (memory adress)
    	poke dword NET_PACKET_ADRESS(NET_PP)+10,NET_PACKET_ADRESS(NET_PP)
    	//--sender choosen player name (12 byte)
    	
    	stringsize=len(client_username)
    	for lda=0 to 12
    		if lda<stringsize+1
    			poke byte NET_PACKET_ADRESS(NET_PP)+14+lda,asc(mid$(client_username,lda))
    		else
    			poke byte NET_PACKET_ADRESS(NET_PP)+14+lda,0
    		endif
    	next lda
    //--Send to target
    winsock send udp message Net_channel(net_cs),NET_PACKET_ADRESS(NET_PP),26
    test_sent=test_sent+1
endif
endfunction

Function NET_M_2(param_IP as string,param_port as integer,param_packetid as dword)
//*****************************************************
//*   Miso                                             
//*     Server replies client, that connection has been refused
//*
//*****************************************************
	NET_PACKET_ADRESS(0)=Make Memory(14)
	NET_PACKET_LENGTH(0)=14
    NET_PACKET_REMOTEIP(0)=param_IP
    NET_PACKET_REMOTEPORT(0)=param_PORT+1
    NET_PACKET_STATUS(0)=0
    winsock set channel target net_channel(net_Ms),NET_PACKET_REMOTEIP(NET_PP),NET_PACKET_REMOTEPORT(NET_PP)
    //--put the data in
    poke dword NET_PACKET_ADRESS(0),net_openfpsid
    poke word NET_PACKET_ADRESS(0)+4,2
    poke dword NET_PACKET_ADRESS(0)+6,0
    poke dword NET_PACKET_ADRESS(0)+10,param_packetid
    //--Send to target
    winsock send udp message Net_channel(NET_MS),NET_PACKET_ADRESS(0),14
    delete memory NET_PACKET_ADRESS(0)
    NET_PACKET_ADRESS(0)=0
Endfunction


Function NET_M_3(param_IP as string,param_port as integer,param_packetid as dword)
//*****************************************************
//*   Miso                                             
//*     Server replies client, that connection has accepted
//*
//*****************************************************
	NET_PACKET_ADRESS(0)=Make Memory(14)
	NET_PACKET_LENGTH(0)=14
    NET_PACKET_REMOTEIP(0)=param_IP
    NET_PACKET_REMOTEPORT(0)=param_PORT+1
    NET_PACKET_STATUS(0)=0
    winsock set channel target net_channel(net_Ms),NET_PACKET_REMOTEIP(NET_PP),NET_PACKET_REMOTEPORT(NET_PP)
    //--put the data in
    poke dword NET_PACKET_ADRESS(0),net_openfpsid
    poke word NET_PACKET_ADRESS(0)+4,3
    poke dword NET_PACKET_ADRESS(0)+6,0
    poke dword NET_PACKET_ADRESS(0)+10,param_packetid
    //--Send to target
    winsock send udp message Net_channel(NET_MS),NET_PACKET_ADRESS(0),14
    delete memory NET_PACKET_ADRESS(0)
    NET_PACKET_ADRESS(0)=0
Endfunction










function net_getmypublicip()
//*****************************************************
//*   Miso                                             
//*     Secondary function to obtain public IP
//*
//*****************************************************

local count as integer
local tmpip as string
local tmpip2 as string
//--count the network interfaces
count=interface count()

	if count>0
		for x=1 to count
		
			tmpip=first token$(ip to string$(interface ip(x)),".")
			tmpip2=next token$(".")
			//--close out local ip 192.168.x.x
			if tmpip<>"192" and tmpip2<>"168"
				//--close out local IP 10.x.x.x and Hamachi interface 5.x.x.x
				if tmpip<>"10" and tmpip<>"5"
					//--close out reserved 172.16.x.x-172.32.x.x
					if tmpip<>"172" 
						if val(tmpip2)<16 or val(tmpip2)>32
							//--close out unknown 0.0.0.0
							if ip to string$(interface ip(x))<>"0.0.0.0"
								net_myip=ip to string$(interface ip(x))
							endif
						endif
					endif
				endif
			endif
			
		next x
	endif
endfunction

function net_getmypublicip2()
//*****************************************************
//*   Miso                                             
//*     Secondary function to obtain public IP
//*
//*****************************************************

local count as integer
local tmpip as string
local tmpip2 as string
//--count the network interfaces
perform checklist for interfaces
count=checklist quantity()
	if count>0
		for x=1 to count
		
			tmpip=first token$(ip to string$(checklist value B(x)),".")
			tmpip2=next token$(".")
			//--looking for routers
			if tmpip="192" and tmpip2="168"
				tmpip=first token$(ip to string$(checklist value D(x)),".")
				tmpip2=next token$(".")
				// close out local ips
				if tmpip<>"192" and tmpip2<>"168"
					//--close out local IP 10.x.x.x and Hamachi interface 5.x.x.x
					if tmpip<>"10" and tmpip<>"5"
						//--close out reserved 172.16.x.x-172.32.x.x
						if tmpip<>"172" 
							if val(tmpip2)<16 or val(tmpip2)>32
								//--close out unknown 0.0.0.0
								if ip to string$(checklist value d(x))<>"0.0.0.0" and ip to string$(checklist value d(x))<>""
									net_myip=ip to string$(checklist value d(x))
									writeln log log_red,"IP found "+net_myip
								endif
							endif
						endif
					endif
				endif
			endif
			
		next x
	endif
endfunction


function net_getmypublicipfullsearch()
//*****************************************************
//*   Miso                                             
//*     Secondary function to obtain public IP, including router check
//*
//*****************************************************
local count as integer
local tmpip as string
local tmpip2 as string
//--count the network interfaces
count=interface count()

	if count>0
		for x=1 to count
		
			tmpip=first token$(ip to string$(interface ip(x)),".")
			tmpip2=next token$(".")
			//--close out local ip 192.168.x.x
			if tmpip<>"192" and tmpip2<>"168"
				//--close out local IP 10.x.x.x and Hamachi interface 5.x.x.x
				if tmpip<>"10" and tmpip<>"5"
					//--close out reserved 172.16.x.x-172.32.x.x
					if tmpip<>"172" 
						if val(tmpip2)<16 or val(tmpip2)>32
							//--close out unknown 0.0.0.0
							if ip to string$(interface ip(x))<>"0.0.0.0"
								net_myip=ip to string$(interface ip(x))
							endif
						endif
					endif
				endif
			endif
			
		next x
	endif

perform checklist for interfaces
count=checklist quantity()
	if count>0
		for x=1 to count
		
			tmpip=first token$(ip to string$(checklist value B(x)),".")
			tmpip2=next token$(".")
			//--looking for routers
			if tmpip="192" and tmpip2="168"
				tmpip=first token$(ip to string$(checklist value D(x)),".")
				tmpip2=next token$(".")
				// close out local ips
				if tmpip<>"192" and tmpip2<>"168"
					//--close out local IP 10.x.x.x and Hamachi interface 5.x.x.x
					if tmpip<>"10" and tmpip<>"5"
						//--close out reserved 172.16.x.x-172.32.x.x
						if tmpip<>"172" 
							if val(tmpip2)<16 or val(tmpip2)>32
								//--close out unknown 0.0.0.0
								if ip to string$(checklist value d(x))<>"0.0.0.0" and ip to string$(checklist value d(x))<>""
									net_myip=ip to string$(checklist value d(x))
									writeln log log_red,"Router DHCP IP found "+net_myip
								endif
							endif
						endif
					endif
				endif
			endif
			
		next x
	endif
endfunction


Function CLIENT_createarrays()
	//--Create user arrays
	dim users_name(0) as string
	dim users_ID(0) as word
	dim users_IP(0) as string
	dim users_port(0) as integer
	
	//--Create game arrays
	dim games_name(0) as string
	dim games_ID(0) as word
	dim games_maxplayers(0) as byte
	dim games_currentplayers(0) as byte
	
	//--create server event array
	dim serverevents(4) as string
	dim chat(200) as string
Endfunction