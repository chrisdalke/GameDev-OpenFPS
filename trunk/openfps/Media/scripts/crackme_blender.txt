import Blender
from Blender import *
from Blender.Object import RBFlags
import random,math
from math import *
from Blender.Mathutils import *
scene=Scene.GetCurrent()
#Blender.Mesh.Mode(1)

#####################################################
#########crackme3d , set properties here#############
#####################################################
crackdetail=4
smoothness=0#0-6 cca
cracks_smooth=1#0 or 1, 1 means cracks get smooth automagic
crackroughness=1./20
crackshape='flat rough'#'flat'#'flat rough'#'spheroid'#'spheroid rough'
numberOfShards=4
######################################################
######################################################
######################################################


def recenterObject(object):
		#new shard center, mass, ...
		m=object.getData(0,1)
		ol=Vector(object.getLocation())
		min=Vector(1000000,1000000,10000000)
		max=Vector(-1000000,-1000000,-10000000)
		for v in m.verts:
			if v.co[0]>max[0]:
				max[0]=v.co[0]
			if v.co[1]>max[1]:
				max[1]=v.co[1]
			if v.co[2]>max[2]:
				max[2]=v.co[2]
			if v.co[0]<min[0]:
				min[0]=v.co[0]
			if v.co[1]<min[1]:
				min[1]=v.co[1]
			if v.co[2]<min[2]:
				min[2]=v.co[2]
		offset=(max+min)/2#-ol
		size=max-min
		for v in m.verts:
			v.co-=offset
		ol+=offset
		object.setLocation(ol)
		m.update()
		return offset,size

def addGEProperties(ob):
			ob.addProperty('age',1)
			ob.addProperty('simulated',0)
			ob.addProperty('shard',1)
			
			ob.rbFlags=84997#softbody215045#rigidbody84997 # crazy flags, didn't understand them so better did copy it
			
			ob.rbRadius=0.01
			#print ob.rbShapeBoundType
			ob.rbShapeBoundType=5 #4- triangle 5- convex
			ob.drawMode=32

def getsizefrommesh(ob):
		bb=ob.getBoundBox()
		#print 'getting size from mesh'
		return bb[5][0]-bb[0][0],bb[3][1]-bb[0][1],bb[1][2]-bb[0][2]

def getIslands(shard):
	sm=shard.getData(0,1)
	islands=[]
	vgroups=[]
	fgroups=[]
	vgi=[]
	for v in sm.verts:
		vgi.append(-1)
	
	gindex=0
	for i in range(len(vgi)):
		if vgi[i]==-1:
			
			gproc=[i]
			vgroups.append([i])
			fgroups.append([])
			while len(gproc)>0:
				i=gproc.pop(0)
				for f in sm.faces:
					#if i in f.verts:
					for v in f.verts:
						if v.index==i:
							for v1 in f.verts:
								if vgi[v1.index]==-1:
									vgi[v1.index]=gindex
									vgroups[gindex].append(v1.index)
									gproc.append(v1.index)
							fgroups[gindex].append(f.index)
			gindex+=1

	if gindex==1:	
		shards=[shard]
	else:
		shards=[]
		for gi in range(0,gindex):
			sm1=Mesh.New()
			shn=scene.objects.new(sm1,'shard')
			sm1.getFromObject(shard)
			for x in range(len(sm1.verts)-1,-1,-1):
				if vgi[x]!=gi:
					print dir (sm1.verts)
					sm1.verts.delete(x)
			shards.append(shn)
			shn.setLocation(shard.getLocation())
			recenterObject(shn)
		scene.objects.unlink(shard)
			
	return shards

def getCrackOb(crackshape,gsize):
	print crackshape[:8]
	
	
	if crackshape[:4]=='flat':
		crackmesh = Mesh.Primitives.Cube(gsize)  
		crackob=scene.objects.new(crackmesh,'crackmesh') 
		crackmesh.sel=0  
		crackmesh.faces[2].sel=1
		
		if crackshape[-5:]=='rough':
			for s in range(crackdetail):
				crackmesh.subdivide()
			for v in crackmesh.verts:
				v.co[0]+=(Rand()-0.5)*gsize*crackroughness	
				
				
	elif crackshape[:8]=='spheroid':
		crackmesh=Mesh.Primitives.Icosphere(crackdetail,gsize)
		if crackshape[-5:]=='rough':
			for v in crackmesh.verts:
				v.co*=1+((Rand()-0.5)*crackroughness	)
		crackob=scene.objects.new(crackmesh,'crackmesh')   

	for v in crackmesh.verts:
		v.co[0]-=gsize/2
	
	

	crackmesh.sel=1
	for f in crackmesh.faces:
		f.smooth=cracks_smooth

	for s in range(smoothness):
		crackmesh.smooth()
	return crackob
	
def splitshard(ob,pos):
	
	fault=0#if it becomes true, boolean op was faulty
	
	Blender.Mesh.Mode(1)
	sizex,sizey,sizez=getsizefrommesh(ob)
	gsize=sizex+sizey+sizez
	
	crackob=getCrackOb(crackshape,gsize)
	
		
	ol=ob.getLocation()
	crackob.setLocation(ol)
	crackob.setEuler((Rand()*5000.0,Rand()*5000.0,Rand()*5000.0))
	Window.RedrawAll() 	
	crackob.makeDisplayList()	
	boolops=[0,2]
	shards=[]
	for bop in boolops:
		sm=Mesh.New()
		s=scene.objects.new(sm,'tempshard')
		s.setLocation(ob.getLocation())
		sm.getFromObject(ob,1)
		mods=s.modifiers
		mod = mods.append(Modifier.Types.BOOLEAN)
		mod[Modifier.Settings.OBJECT] = crackob
		mod[Modifier.Settings.OPERATION] = bop
		s.makeDisplayList() 
		Window.RedrawAll()   
		
		sh=Mesh.New()
		
		sh.getFromObject(s,0)
		scene.objects.unlink(s)
		
		
		if len(sh.verts)>1:#shouldn't happen!!!!
			sh.update()
			
			shard = scene.objects.new(sh,'shard')
			sh.recalcNormals()
			shard.setLocation(ob.getLocation())
			#shard.makeDisplayList()
			of, size = recenterObject(shard)
			
			gsize2=size[0]+size[1]+size[2]
			if gsize2>gsize:#all various checks for mesh correctnes, it fault gets 1, whole splitting round gets thrashed
				fault=1
				print 'fault'
			else:
				es=[]
				for e in sh.edges:
					es.append(0)
				for f in sh.faces:

					for e in f.edge_keys:
						i=sh.findEdges(e[0],e[1])
						es[i]+=1
				for ecount in es:
					if ecount<2:
						print 'wrong number of edge users'
						fault=1
						
			if not fault:
				newshards=getIslands(shard)
				shards.extend(newshards)				
				for shard in shards:
					addGEProperties(shard)
					
				
					shard.makeDisplayList()
				
			else:
				shards.append(shard)
			
			
	scene.objects.unlink(crackob)

	if fault: 
		for s in shards:
			scene.objects.unlink(s)
		return [ob]
	else:
		scene.objects.unlink(ob)
		return shards
		

def splitSelected():
	obs= Object.GetSelected()
	for ob in obs:
	
		nm=Mesh.New()
		nob=scene.objects.new(nm,'copy')
		nm.getFromObject(ob,1)
		nob.setLocation(ob.getLocation())
		empty=scene.objects.new('Empty','shardelementadder')
		empty.setLocation(nob.getLocation())
		empty.addProperty('object',nob.name)
		scene.objects.unlink(ob)
		gshards = splitshard(nob,0)
		i=0
		while i<(numberOfShards):
			if len(gshards)>0:
				ss=gshards.pop(0)
				news=splitshard(ss,0)
				gshards.extend(news)
				if ss!=news[0]:
					i+=len(news)
				else:i+=1
	
splitSelected()