remstart
/////////////////////////////////////////////////////
//
//   OpenFPS
//   MAIN SOURCE
//
//
/////////////////////////////////////////////////////

----- Changelog (main source file only):
(11/19/09) - BMacZero - Created
(11/23/09) - BMacZero - Added menu
(11/24/09) - BMacZero - [Removed BlitzTerrain temporarily]

----- To-Do
Modules should be init between initMenu() and runMenu().
However, movement module does not work properly - fix.

remend

/////////////////////////////////////////////////////////
// INIT                                                //
/////////////////////////////////////////////////////////

sync on : sync rate 60
autocam off
randomize timer()


`/ INITIATE CORE MODULES
initResource()


`/ START LOADING
initMenu()


`/ RUN MENU
runMenu()


`Init other modules here
initMovement()

`=================================================================
`==== TEST CODE - SHOULD NOT BE USED LATER

remstart
bt_HeightmapImage  = grabResource(res_Image)
bt_TexturemapImage = grabResource(res_Image)
bt_DetailmapImage  = grabResource(res_Image)

//make terrain
load image "media/BlitzTerrain/Heightmap.bmp", bt_HeightmapImage
load image "media/BlitzTerrain/texture.jpg",   bt_TexturemapImage
load image "media/BlitzTerrain/detail.tga",    bt_DetailmapImage

terrain=UT MakeTerrain()
UT SetTerrainHeightmap terrain, bt_HeightmapImage
UT SetTerrainTexture terrain,   bt_TexturemapImage
UT SetTerrainDetail terrain,    bt_DetailmapImage
`Set how many LOD levels there are
UT SetTerrainLOD terrain,3
UT SetTerrainScale terrain,20
UT SetTerrainYScale terrain,3

`Set the split (the terrain will be 8x8 so it will generate 64 sectors)
UT SetTerrainSplit terrain,8
UT SetTerrainDetailTile terrain,2
UT SetTerrainLODDistances terrain,1000,3000,5500,0,0,0

UT BuildTerrain terrain

type bt_GroundType
    obj as integer
    phy as integer
endtype

DIM bt_GroundObjects(0) as bt_GroundType

repeat
    array insert at top bt_GroundObjects(0)
    bt_GroundObjects(1).obj=grabResource(res_Object)
    bt_GroundObjects(1).phy=grabResource(res_Object)
    progress=UT ContinueBuild(bt_GroundObjects(1).obj,bt_GroundObjects(1).phy,0)
    sc_setupcomplexobject bt_GroundObjects(1).phy,0,4
until progress=-1

UT InitialiseTerrain terrain

remend

planeObj = grabResource(res_Object)
make object box planeObj,2000,200,2000
sc_setupobject planeObj,0,2

hide mouse
backdrop on

`==
`====================================================================

/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////
// MAIN LOOP                                           //
/////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////

do

updateMovement()

text 10,10,str$(screen fps())

sync
loop
end


remstart
/////////////////////////////////////////////////////
//
// OpenFPS MOVEMENT Module
//
// Created by Monk
// Maintained by Monk and BMacZero
//
/////////////////////////////////////////////////////

----- Changelog:
(07/26/09) - BMacZero - Modularized
                      - Switched crouch and prone to individual
                        toggles.
(11/23/09) - BMacZero - Brought in line with R/M module.
(11/24/09) - BMacZero - [Starting position changed to origin]


----- To-Do:
Apply different speeds and jump heights for different classes.
Add more realism - camera bobs slightly when walking, more when
  running.  Camera bobs down before jumping.  Camera dips after
  landing from a jump - more if it was a hard landing.


----- Purpose:
Handles player input as it applies to moving about the world.
This includes movement, sprinting, crouching, crawling, and
  collision and gravity for the player.
It may also do falling damage at a later time.


----- Dependancies and Conflicts (IMPORTANT STUFF):
All objects the player needs to collide with must be set up
  for Sparky's Collision.

The module requires the player's class to be stored in a global
  integer PLR_class, as different classes have different speeds,
  heights, and jump heights.

Configurable Keys: Keystates should be stored in the following
  global integers:
    KEY_sprint
    KEY_jump
    KEY_left
    KEY_right
    KEY_forward
    KEY_backward
    KEY_crouch
    KEY_prone


----- Other Notes:
Information about the player will be stored in the following
  global floats...
  PLR_footpos.x / y / z
  PLR_headpos.x / y / z
  PLR_angle.x / y / z
  PLR_velocity.x / y / z
  PLR_stamina
  
The player's stance (walk, sprint, crouch, prone) will be
  stored in the integer PLR_stance, relating to the constants
  stance_SPRINT, stance_WALK, stance_CROUCH, and stance_PRONE.
  
The module contains its own timer-based system.  Any code relating
  to this is marked with //MOVEMENT MODULE TIMER incase the system
  needs to be brought in line with a global one later.
  
All movements are scaled to:
  60 units = 1 meter


remend

`Player stances
#constant stance_SPRINT 0
#constant stance_WALK   1
#constant stance_CROUCH 2
#constant stance_PRONE  3

`Random memblock commands for Sparky's
null = memblock exist(1)

`Vector type
type vector
   x as float
   y as float
   z as float
endtype


/////////////////////////////////////////////////////////
// INIT                                                //
/////////////////////////////////////////////////////////


function initMovement()

`Initiate controls
if KEY_sprint   = 0
    global KEY_sprint   as integer
    KEY_sprint   = 42
endif
if KEY_jump     = 0
    global KEY_jump     as integer
    KEY_jump     = 57
endif
if KEY_left     = 0
    global KEY_left     as integer
    KEY_left     = 30
endif
if KEY_right    = 0 
    global KEY_right    as integer
    KEY_right    = 32
endif
if KEY_forward  = 0
    global KEY_forward  as integer
    KEY_forward  = 17
endif
if KEY_backward = 0
    global KEY_backward as integer
    KEY_backward = 31
endif
if KEY_crouch   = 0
    global KEY_crouch   as integer
    KEY_crouch   = 46
endif
if KEY_prone    = 0
    global KEY_prone    as integer
    KEY_prone    = 47
endif

global PLR_footpos  as vector
global PLR_headpos  as vector
global PLR_velocity as vector
global PLR_angle    as vector

global PLR_object   as integer
global PLR_stance   as integer

global DIM PLR_speeds(3)  as float
global DIM PLR_heights(3) as float

global PLR_gravity       as float
global PLR_heightspeed   as float `How fast the player crouches and such
global PLR_currentheight as float

global MOVE_keypress  as boolean
global MOVE_fall      as boolean
global MOVE_jumppress as boolean
global MOVE_jump      as boolean

//vars
PLR_speeds(stance_WALK)   = 180.0
PLR_speeds(stance_SPRINT) = PLR_speeds(stance_WALK) * 2.00
PLR_speeds(stance_CROUCH) = PLR_speeds(stance_WALK) * 0.45
PLR_speeds(stance_PRONE)  = PLR_speeds(stance_WALK) * 0.20

PLR_heights(stance_WALK)   = 120.0
PLR_heights(stance_SPRINT) = 110.0
PLR_heights(stance_CROUCH) = 55.0
PLR_heights(stance_PRONE)  = 15.0

PLR_object    = 1
PLR_footpos.x = 0.0
PLR_footpos.y = 5.0
PLR_footpos.z = 0.0
PLR_stance    = stance_WALK
PLR_headpos.x = PLR_footpos.x
PLR_headpos.y = PLR_footpos.y + PLR_heights(PLR_stance)
PLR_headpos.z = PLR_footpos.z

PLR_gravity       = -550.0
PLR_heightspeed   = 3.0
PLR_currentheight = PLR_heights(stance_WALK)

PLR_stamina as float

//misc
global mov_Mat1
global mov_Mat2
global mov_Mat3
global mov_Mat4
global mov_Vec5
global mov_Vec6
global mov_Vec7
mov_Mat1 = grabResource(res_Matrix4)
mov_Mat2 = grabResource(res_Matrix4)
mov_Mat3 = grabResource(res_Matrix4)
mov_Mat4 = grabResource(res_Matrix4)
mov_Vec5 = grabResource(res_Vector3)
mov_Vec6 = grabResource(res_Vector3)
mov_Vec7 = grabResource(res_Vector3)
null = Make Matrix4( mov_Mat1 )
null = Make Matrix4( mov_Mat2 )
null = Make Matrix4( mov_Mat3 )
null = Make Matrix4( mov_Mat4 )
null = Make Vector3( mov_Vec5 ) // lX
null = Make Vector3( mov_Vec6 ) // lY
null = Make Vector3( mov_Vec7 ) // lZ

//MOVEMENT MODULE TIMER
global timer_starttime as dword
global synctime as float
timer_starttime = timer()
//MOVEMENT MODULE TIMER

endfunction


/////////////////////////////////////////////////////////
// UPDATE                                              //
/////////////////////////////////////////////////////////


function updateMovement()

local movementx as float
local movementy as float
local movementz as float

//MOVEMENT MODULE TIMER
local elapsedtime as float
elapsedtime=(timer()-timer_starttime)/1000.0
timer_starttime = timer()
//MOVEMENT MODULE TIMER

//moving
Set Vector3 mov_Vec5, 1.0, 0.0, 0.0
Build Rotation Axis Matrix4 mov_Mat1, mov_Vec5, PLR_angle.x * 0.017453292519943295769236907684886
Set Vector3 mov_Vec5, 0.0, 1.0, 0.0
Build Rotation Axis Matrix4 mov_Mat2, mov_Vec5, PLR_angle.y * 0.017453292519943295769236907684886
Set Vector3 mov_Vec5, 0.0, 0.0, 1.0
Build Rotation Axis Matrix4 mov_Mat3, mov_Vec5, PLR_angle.z * 0.017453292519943295769236907684886
Multiply Matrix4 mov_Mat4, mov_Mat1, mov_Mat2
Multiply Matrix4 mov_Mat4, mov_Mat4, mov_Mat3

Set Vector3 mov_Vec5, 1.0, 0.0, 0.0
Transform Coords Vector3 mov_Vec5, mov_Vec5, mov_Mat4
Set Vector3 mov_Vec6, 0.0, 1.0, 0.0
Transform Coords Vector3 mov_Vec6, mov_Vec6, mov_Mat4
Set Vector3 mov_Vec7, 0.0, 0.0, 1.0
Transform Coords Vector3 mov_Vec7, mov_Vec7, mov_Mat4

`Find Left/Right and Forward/Back movement
movementx = (keystate(KEY_right)   - keystate(KEY_left))     * PLR_speeds(PLR_stance)
movementz = (keystate(KEY_forward) - keystate(KEY_backward)) * PLR_speeds(PLR_stance)

`Set velocities if we're on the ground
if MOVE_fall = 0
   PLR_velocity.x = X Vector3(mov_Vec5) * movementx
   PLR_velocity.z = Z Vector3(mov_Vec5) * movementx
   PLR_velocity.x = PLR_velocity.x + X Vector3(mov_Vec6) * movementy + X Vector3(mov_Vec7) * movementz
   PLR_velocity.z = PLR_velocity.z + Z Vector3(mov_Vec6) * movementy + Z Vector3(mov_Vec7) * movementz
endif

//stance change
if keystate(KEY_sprint)
   PLR_stance = stance_SPRINT
   PLR_object = 1
endif

if keystate(KEY_crouch) and MOVE_keypress = 0
   MOVE_keypress = 1
   if PLR_stance = stance_CROUCH
      PLR_stance = stance_WALK
      else
      PLR_stance = stance_CROUCH
   endif
endif

if keystate(KEY_prone) and MOVE_keypress = 0
   MOVE_keypress = 1
   if PLR_stance = stance_PRONE
      PLR_stance = stance_WALK
      else
      PLR_stance = stance_PRONE
   endif
endif


//collision
ground = sc_spherecast(0,PLR_headpos.x,PLR_headpos.y-2,PLR_headpos.z,PLR_footpos.x,PLR_footpos.y+2,PLR_footpos.z,2,PLR_object)
if ground <> 0
   `damage# = ((-PLR_velocity.y) - 100.0)
   MOVE_fall = 0
   PLR_velocity.y = 0
//amendments for uneven terrain
   PLR_footpos.y = sc_getcollisionslidey()-2    //positions the player at the appropriate height
   temp# = sc_getcollisionnormaly()                //how flat the land is 1 for flat, 0 for vertical
   if temp#<0.4 then temp#=0
   PLR_velocity.x = PLR_velocity.x * temp#             //adjust speed to make up for grade
   PLR_velocity.z = PLR_velocity.z * temp#
else
   //MOVEMENT MODULE TIMER
   PLR_velocity.y = PLR_velocity.y + PLR_gravity * elapsedtime
   //MOVEMENT MODULE TIMER
endif

//jumping
if keystate(KEY_jump) and MOVE_jumppress = 0 and MOVE_fall = 0
   PLR_stance = stance_WALK
   MOVE_jumppress = 1
   MOVE_jump = 1
endif

if MOVE_jump and MOVE_fall = 0
   MOVE_jump = 0
   MOVE_fall = 1
   PLR_velocity.y = PLR_velocity.y + 300.0
endif


//update
//MOVEMENT MODULE TIMER
PLR_footpos.x = PLR_footpos.x + PLR_velocity.x * elapsedtime
PLR_footpos.y = PLR_footpos.y + PLR_velocity.y * elapsedtime
PLR_footpos.z = PLR_footpos.z + PLR_velocity.z * elapsedtime
//MOVEMENT MODULE TIMER

`Update playersize
if PLR_heights(PLR_stance)>PLR_currentheight
    inc PLR_currentheight,PLR_heightspeed
    if PLR_currentheight>PLR_heights(PLR_stance) then PLR_currentheight = PLR_heights(PLR_stance)
endif
if PLR_heights(PLR_stance)<PLR_currentheight
    dec PLR_currentheight,PLR_heightspeed
    if PLR_currentheight<PLR_heights(PLR_stance) then PLR_currentheight = PLR_heights(PLR_stance)
endif

PLR_headpos.x = PLR_footpos.x
PLR_headpos.y = PLR_footpos.y + PLR_currentheight
PLR_headpos.z = PLR_footpos.z

PLR_angle.y = PLR_angle.y + mousemovex()*0.2
PLR_angle.x = PLR_angle.x + mousemovey()*0.2

if keystate(KEY_jump) = 0 then MOVE_jumppress = 0
if keystate(KEY_prone) = 0 and keystate(KEY_crouch) = 0 then MOVE_keypress = 0

if keystate(KEY_sprint) = 0 and PLR_stance = stance_SPRINT
   PLR_stance = stance_WALK
endif

//MOVEMENT MODULE TIMER
synctime = synctime + elapsedtime
if synctime > 0.01
    synctime = 0
    position camera 0, PLR_headpos.x, PLR_headpos.y, PLR_headpos.z
    rotate camera 0, PLR_angle.x, PLR_angle.y, PLR_angle.z
endif
//MOVEMENT MODULE TIMER

endfunction


/////////////////////////////////////////////////////////
// TERMINATE                                           //
/////////////////////////////////////////////////////////


function terminateMovement()

UNDIM PLR_speeds(0)
UNDIM PLR_heights(0)

null = delete matrix4( mov_Mat1 )
null = delete matrix4( mov_Mat2 )
null = delete matrix4( mov_Mat3 )
null = delete matrix4( mov_Mat4 )
null = delete vector3( mov_Vec5 )
null = delete vector3( mov_Vec6 )
null = delete vector3( mov_Vec7 )

freeResource(mov_Mat1,res_Matrix4)
freeResource(mov_Mat2,res_Matrix4)
freeResource(mov_Mat3,res_Matrix4)
freeResource(mov_Mat4,res_Matrix4)
freeResource(mov_Vec5,res_Vector3)
freeResource(mov_Vec6,res_Vector3)
freeResource(mov_Vec7,res_Vector3)

endfunction

remstart
/////////////////////////////////////////////////////
//
// OpenFPS RESOURCE MANAGEMENT Core Module
//
// Created by BMacZero
// Maintained by BMacZero
//
/////////////////////////////////////////////////////

----- Changelog:
(11/18/09) - BMacZero - Created


----- To-Do:
Test


----- Purpose:
Assigns and frees resource numbers (ANYTHING that requires an
    identification number with DB)


----- Dependancies and Conflicts (IMPORTANT STUFF):
-None-


----- Other Notes:
Usage (IMPORTANT***):
Whenever ANY module needs ANY type of resource for ANY reason,
    it MUST go through this module. (Not including BlitzTerrains)
How do you do that?  Call the grabResource() function.  The parameter
    represents the type of resource you want (see the constant
    declarations after these statements).
When you are through with a resource, free it with the freeResource()
    function so it can be reused.


remend

#Constant res_Object   0
#Constant res_Image    1
#Constant res_Sprite   2
#Constant res_File     3
#Constant res_Sound    4
#Constant res_Music    5
#Constant res_Memblock 6
#Constant res_Bitmap   7
#Constant res_Anim     8
#Constant res_Light    9
#Constant res_Camera   10
#Constant res_Mesh     11
#Constant res_Matrix   12
#Constant res_Particle 13
#Constant res_Matrix4  14
#Constant res_Vector2  15
#Constant res_Vector3  16
#Constant res_Vector4  17
#Constant res_DLL      18

#Constant res_Count    18

type res_Type
    start as integer
    qty as integer
endtype


/////////////////////////////////////////////////////////
// INIT                                                //
/////////////////////////////////////////////////////////


function initResource()

global DIM ResourceCounters(res_Count)   as integer
global DIM FreeResourcesIndex(res_Count) as res_Type
global DIM FreeResources(0)              as integer

endfunction


/////////////////////////////////////////////////////////
// CORE                                                //
/////////////////////////////////////////////////////////


function grabResource(restype)

local result as integer

if FreeResourcesIndex(restype).qty=0
    inc ResourceCounters(res_Count)
    result=ResourceCounters(res_Count)
    
    else
    result=FreeResources(FreeResourcesIndex(restype).start)
    array delete element FreeResources(0),FreeResourcesIndex(restype).start
    dec FreeResourcesIndex(restype).qty
    
    for d=restype+1 to res_Count
        dec FreeResourcesIndex(d).start
    next d
endif    

endfunction result



function freeResource(number,restype)

local temp as integer

`Delete it if it hasn't been
select restype
    case res_Object
        if object exist(number) then delete object number
    endcase
    case res_Image
        if image exist(number) then delete image number
    endcase
    case res_Sprite
        if sprite exist(number) then delete sprite number
    endcase
    case res_File
        if file open(number) then close file number
    endcase
    case res_Sound
        if sound exist(number) then delete sound number
    endcase
    case res_Music
        if music exist(number) then delete music number
    endcase
    case res_Memblock
        if memblock exist(number) then delete memblock number
    endcase
    case res_Bitmap
        if bitmap exist(number) then delete bitmap number
    endcase
    case res_Anim
        if animation exist(number) then delete animation number
    endcase
    case res_Light
        if light exist(number) then delete light number
    endcase
    case res_Camera
        if camera exist(number) then delete camera number
    endcase
    case res_Mesh
        if mesh exist(number) then delete mesh number
    endcase
    case res_Matrix
        if matrix exist(number) then delete matrix number
    endcase
    case res_Particle
        if particles exist(number) then delete particles number
    endcase
    case res_Matrix4
        `if matrix4 exist(number) then delete matrix4 number
    endcase
    case res_Vector2
        `if vector2 exist(number) then delete vector2 number
    endcase
    case res_Vector3
        `if vector3 exist(number) then delete vector3 number
    endcase
    case res_Vector4
        `if vector4 exist(number) then delete vector4 number
    endcase
    case res_DLL
        if dll exist(number) then delete dll number
    endcase
    case default
        exitfunction
    endcase
endselect

if number=ResourceCounters(restype)
    dec ResourceCounters(restype)
    else
    temp=FreeResourcesIndex(restype).start+FreeResourcesIndex(restype).qty
    array insert at element FreeResources(0),temp
    FreeResources(temp)=number
    inc FreeResourcesIndex(restype).qty
    
    for d=restype+1 to res_Count
        inc FreeResourcesIndex(d).start
    next d
endif

endfunction


/////////////////////////////////////////////////////////
// TERMINATE                                           //
/////////////////////////////////////////////////////////


function terminateResource()

UNDIM ResourceCounters(0)
UNDIM FreeResourcesIndex(0)
UNDIM FreeResources(0)

endfunction
remstart
/////////////////////////////////////////////////////
//
// OpenFPS MENU Module
//
// Created by thenerd
// Maintained by thenerd
//
/////////////////////////////////////////////////////

----- Changelog:
(11/19/09) - BMacZero - Adapted to existing code.


----- To-Do:
Make buttons functional.


----- Purpose:
Runs the menu.


----- Dependancies and Conflicts (IMPORTANT STUFF):
-None-


----- Other Notes:



remend



/////////////////////////////////////////////////////////
// INIT                                                //
/////////////////////////////////////////////////////////

function initMenu()

global menu_loadingimage
global menu_loadingsprite
menu_loadingimage  = grabResource(res_Image)
menu_loadingsprite = grabResource(res_Sprite)
load image "media\menu\loading-1.png",menu_loadingimage
sprite menu_loadingsprite,0,0,menu_loadingimage
set sprite priority menu_loadingsprite,1

global menu_mainimage
global menu_mainsprite
menu_mainimage  = grabResource(res_Image)
menu_mainsprite = grabResource(res_Sprite)
load image "media\menu\main.png",menu_mainimage
sprite menu_mainsprite,0,0,menu_mainimage
show sprite menu_mainsprite

endfunction



/////////////////////////////////////////////////////////
// CORE                                                //
/////////////////////////////////////////////////////////

function runMenu()

local alpha as byte

`Transition out of loading
alpha=255
do
	alpha=alpha-20
	if alpha<20 then exit
	set sprite alpha menu_loadingsprite,alpha
	sync
loop
set sprite alpha menu_loadingsprite,0


global menu_button1 = grabResource(res_Image)
global menu_button2 = grabResource(res_Image)
global menu_button3 = grabResource(res_Image)

load image "media\menu\button-normal.png",menu_button1
load image "media\menu\button-hover.png",menu_button2
load image "media\menu\button-clicked.png",menu_button3
hide sprite menu_mainsprite
do
	paste sprite menu_mainsprite,0,0
	if button("New Game",78,219)=1 then exit
	button("Load Game",78,279)
	button("Help/How To Play",78,339)
	button("Options",78,399)
	button("Credits",78,459)
	button("Quit",78,519)
	sync
loop

freeResource(menu_mainsprite   ,res_Sprite)
freeResource(menu_mainimage    ,res_Image )
freeResource(menu_loadingsprite,res_Sprite)
freeResource(menu_loadingimage ,res_Image )

freeResource(menu_button1,res_Image)
freeResource(menu_button2,res_Image)
freeResource(menu_button3,res_Image)

endfunction



/////////////////////////////////////////////////////////
// SUPPORT                                             //
/////////////////////////////////////////////////////////


function button(text$,x,y):
	clicked=0
	mouse=in_box2d(x,y,x+178,y+50)
	if mouse=0 then paste image menu_button1,x,y,1
	if mouse=1 then paste image menu_button2,x,y,1
	if mouse=2 then paste image menu_button3,x,y,1:clicked=1
	center text x+89,y+25-(text height("OOO")/2),text$
endfunction clicked

function in_box2d(x1,y1,x2,y2):
	mx=MouseX()
	my=MouseY()
	result=0
	if (mx >= x1) and (mx <= x2) and (my >= y1) and (my <= y2):
		if mouseclick()=0 then result = 1
		if mouseclick()=1 then result = 2
	endif
endFunction result 